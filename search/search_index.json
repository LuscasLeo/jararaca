{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Jararaca Microservice Framework","text":"<p>Jararaca is a powerful Python microservice framework that provides a comprehensive set of tools and abstractions for building robust microservice architectures. It integrates seamlessly with FastAPI, SQLAlchemy, Redis, and RabbitMQ to deliver a complete solution for modern microservice development.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>\ud83d\ude80 FastAPI Integration: Built-in support for FastAPI with automatic OpenAPI documentation</li> <li>\ud83c\udf10 HTTP RPC Client: Complete REST client implementation with decorators, authentication, caching, and retry logic</li> <li>\ud83d\udd0c WebSocket Support: Real-time communication capabilities with Redis-backed WebSocket management</li> <li>\ud83d\udce6 Dependency Injection: Flexible dependency injection system with interceptors</li> <li>\ud83d\udcca Database Integration: SQLAlchemy integration with async support</li> <li>\ud83d\udce1 Message Bus: RabbitMQ integration for event-driven architecture</li> <li>\u26a1 Retry Mechanism: Robust retry system with exponential backoff for resilient operations</li> <li>\ud83d\udd0d Query Operations: Advanced query capabilities with pagination and filtering</li> <li>\u23f1\ufe0f Scheduled Tasks: Distributed cron-based task scheduling with message broker integration</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install jararaca\n</code></pre>"},{"location":"#cli-commands","title":"CLI Commands","text":"<p>Jararaca comes with a powerful command-line interface to help you manage your microservices:</p>"},{"location":"#worker-message-bus-worker","title":"<code>worker</code> - Message Bus Worker","text":"<pre><code>jararaca worker APP_PATH [OPTIONS]\n</code></pre> <p>Starts a message bus worker that processes asynchronous messages from a message queue.</p> <p>Options:</p> <ul> <li><code>--broker-url</code>: The URL for the message broker (required) [env: BROKER_URL]</li> <li><code>--backend-url</code>: The URL for the message broker backend (required) [env: BACKEND_URL]</li> <li><code>--handlers</code>: Comma-separated list of handler names to listen to (optional) [env: HANDLERS]</li> <li><code>--reload</code>: Enable auto-reload when Python files change (for development) [env: RELOAD]</li> <li><code>--src-dir</code>: The source directory to watch for changes when --reload is enabled (default: \"src\") [env: SRC_DIR]</li> </ul> <p>Environment Variables: - <code>APP_PATH</code>: The application module path - All options support environment variables as indicated above</p> <p>Example with environment variables: <pre><code>export APP_PATH=\"app.module:app\"\nexport BROKER_URL=\"amqp://guest:guest@localhost:5672/?exchange=jararaca&amp;prefetch_count=1\"\nexport BACKEND_URL=\"redis://localhost:6379\"\nexport HANDLERS=\"send_email,process_payment\"\nexport RELOAD=\"true\"\njararaca worker\n</code></pre> - <code>--reload</code>: Enable auto-reload when Python files change (for development) - <code>--src-dir</code>: The source directory to watch for changes when --reload is enabled (default: \"src\")</p>"},{"location":"#server-http-server","title":"<code>server</code> - HTTP Server","text":"<pre><code>jararaca server APP_PATH [OPTIONS]\n</code></pre> <p>Starts a FastAPI HTTP server for your microservice.</p> <p>Options:</p> <ul> <li><code>--host</code>: Host to bind the server (default: \"0.0.0.0\") [env: HOST]</li> <li><code>--port</code>: Port to bind the server (default: 8000) [env: PORT]</li> </ul> <p>Environment Variables: - <code>APP_PATH</code>: The application module path - <code>HOST</code>: Host to bind the server - <code>PORT</code>: Port to bind the server</p> <p>Example with environment variables: <pre><code>export APP_PATH=\"app.module:app\"\nexport HOST=\"127.0.0.1\"\nexport PORT=\"8080\"\njararaca server\n</code></pre></p>"},{"location":"#alternative-using-uvicorn-directly","title":"Alternative: Using <code>uvicorn</code> directly","text":"<p>For production environments, you can create an ASGI application and run it with uvicorn:</p> <pre><code>from fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom fastapi.types import Lifespan\n\nfrom jararaca import HttpMicroservice, create_http_server\n\n\ndef fastapi_factory(lifespan: Lifespan[FastAPI]) -&gt; FastAPI:\n    app = FastAPI(\n        lifespan=lifespan,\n    )\n\n    app.router.prefix = \"/api\"\n\n    app.add_middleware(\n        CORSMiddleware,\n        allow_origins=[\"*\"],\n        allow_credentials=True,\n        allow_methods=[\"*\"],\n        allow_headers=[\"*\"],\n        expose_headers=[\"error\", \"reason\", \"scope\"],\n    )\n\n    return app\n\n\nhttp_app = HttpMicroservice(app, fastapi_factory)\n\nasgi_app = create_http_server(http_app)\n</code></pre> <p>Then run the server with:</p> <pre><code>uvicorn app_module:asgi_app\n</code></pre>"},{"location":"#beat-task-scheduler","title":"<code>beat</code> - Task Scheduler","text":"<pre><code>jararaca beat APP_PATH [OPTIONS]\n</code></pre> <p>Runs scheduled tasks defined in your application using cron expressions.</p> <p>Options:</p> <ul> <li><code>--interval</code>: Polling interval in seconds (default: 1) [env: INTERVAL]</li> <li><code>--broker-url</code>: The URL for the message broker (required) [env: BROKER_URL]</li> <li><code>--backend-url</code>: The URL for the message broker backend (required) [env: BACKEND_URL]</li> <li><code>--actions</code>: Comma-separated list of action names to run (optional) [env: ACTIONS]</li> <li><code>--reload</code>: Enable auto-reload when Python files change (for development) [env: RELOAD]</li> <li><code>--src-dir</code>: The source directory to watch for changes when --reload is enabled (default: \"src\") [env: SRC_DIR]</li> </ul> <p>Environment Variables: - <code>APP_PATH</code>: The application module path - All options support environment variables as indicated above</p> <p>Example with environment variables: <pre><code>export APP_PATH=\"app.module:app\"\nexport INTERVAL=\"5\"\nexport BROKER_URL=\"amqp://guest:guest@localhost:5672/?exchange=jararaca&amp;prefetch_count=1\"\nexport BACKEND_URL=\"redis://localhost:6379\"\nexport ACTIONS=\"send_emails,process_payments\"\nexport RELOAD=\"true\"\njararaca beat\n</code></pre></p> <pre><code>jararaca scheduler_v2 APP_PATH [OPTIONS]\n</code></pre> <p>Runs an enhanced version of the task scheduler with support for message broker backend integration.</p> <p>Options:</p> <ul> <li><code>--interval</code>: Polling interval in seconds (default: 1, required)</li> <li><code>--broker-url</code>: The URL for the message broker (required)</li> <li><code>--backend-url</code>: The URL for the message broker backend (required)</li> </ul>"},{"location":"#gen-tsi-generate-typescript-interfaces","title":"<code>gen-tsi</code> - Generate TypeScript Interfaces","text":"<pre><code>jararaca gen-tsi APP_PATH FILE_PATH [OPTIONS]\n</code></pre> <p>Generates TypeScript interfaces from your Python models to ensure type safety between your frontend and backend.</p> <p>Options:</p> <ul> <li><code>--watch</code>: Watch for file changes and regenerate TypeScript interfaces automatically [env: WATCH]</li> <li><code>--src-dir</code>: Source directory to watch for changes (default: \"src\") [env: SRC_DIR]</li> <li><code>--stdout</code>: Print generated interfaces to stdout instead of writing to a file [env: STDOUT]</li> <li><code>--post-process</code>: Command to run after generating the interfaces, {file} will be replaced with the output file path [env: POST_PROCESS]</li> </ul> <p>Environment Variables: - <code>APP_PATH</code>: The application module path - All options support environment variables as indicated above</p> <p>Example with watch mode:</p> <pre><code>jararaca gen-tsi app.module:app interfaces.ts --watch\n</code></pre> <p>This will generate the TypeScript interfaces initially and then watch for any changes to Python files in the src directory, automatically regenerating the interfaces when changes are detected. You can stop watching with Ctrl+C.</p> <p>Example with environment variables: <pre><code>export APP_PATH=\"app.module:app\"\nexport FILE_PATH=\"interfaces.ts\"\nexport WATCH=\"true\"\nexport SRC_DIR=\"src\"\njararaca gen-tsi\n</code></pre></p> <p>Note: To use the watch feature, you need to install the watchdog package:</p> <pre><code>pip install jararaca[watch]\n</code></pre> <p>Or directly:</p> <pre><code>pip install watchdog\n</code></pre>"},{"location":"#gen-entity-generate-entity-template","title":"<code>gen-entity</code> - Generate Entity Template","text":"<pre><code>jararaca gen-entity ENTITY_NAME FILE_PATH\n</code></pre> <p>Generates a new entity file template with proper naming conventions in different formats (snake_case, PascalCase, kebab-case).</p> <p>Environment Variables: - <code>ENTITY_NAME</code>: The name of the entity to generate - <code>FILE_PATH</code>: The path where the entity file should be created</p> <p>Example:</p> <pre><code># Using command line arguments\njararaca gen-entity User user.py\n\n# Using environment variables\nexport ENTITY_NAME=\"User\"\nexport FILE_PATH=\"user.py\"\njararaca gen-entity\n</code></pre>"},{"location":"#declare-declare-message-infrastructure","title":"<code>declare</code> - Declare Message Infrastructure","text":"<pre><code>jararaca declare APP_PATH [OPTIONS]\n</code></pre> <p>Declares RabbitMQ infrastructure (exchanges and queues) for message handlers and schedulers without starting the actual consumption processes.</p> <p>Options: - <code>--broker-url</code>: Broker URL (e.g., amqp://guest:guest@localhost/) [env: BROKER_URL] - <code>-i, --interactive-mode</code>: Enable interactive mode for queue declaration [env: INTERACTIVE_MODE] - <code>-f, --force</code>: Force recreation by deleting existing exchanges and queues [env: FORCE]</p> <p>Environment Variables: - <code>APP_PATH</code>: The application module path - <code>BROKER_URL</code>: The broker URL - <code>INTERACTIVE_MODE</code>: Enable interactive mode - <code>FORCE</code>: Force recreation of infrastructure</p> <p>Examples:</p> <pre><code># Declare infrastructure\njararaca declare myapp:app --broker-url amqp://guest:guest@localhost/\n\n# Force recreation of queues and exchanges\njararaca declare myapp:app --broker-url amqp://guest:guest@localhost/ --force\n\n# Using environment variables\nexport APP_PATH=\"myapp:app\"\nexport BROKER_URL=\"amqp://guest:guest@localhost/\"\nexport FORCE=\"true\"\njararaca declare\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Here's a basic example of how to create a microservice with Jararaca:</p> <pre><code>from app.app_config import AppConfig, AppFactoryWithAppConfig\nfrom app.auth.auth_controller import (\n    AuthConfig,\n    AuthController,\n    InMemoryTokenBlackListService,\n    TokenBlackListService,\n)\nfrom app.extraction.models_controller import ExtractionModelController\nfrom app.extraction.secrets_controller import SecretsController\nfrom app.extraction.tasks_controller import TasksController\nfrom app.providers import REDIS_TOKEN\nfrom redis.asyncio import Redis\n\nfrom jararaca import (\n    AIOPikaConnectionFactory,\n    AIOSQAConfig,\n    AIOSqlAlchemySessionInterceptor,\n    AppConfigurationInterceptor,\n    HttpMicroservice,\n    MessageBusPublisherInterceptor,\n    Microservice,\n    ProviderSpec,\n    RedisWebSocketConnectionBackend,\n    Token,\n    WebSocketInterceptor,\n    create_http_server,\n)\n\n# Create your microservice instance\napp = Microservice(\n    providers=[\n        # Redis provider for caching and WebSocket management\n        ProviderSpec(\n            provide=REDIS_TOKEN,\n            use_factory=AppFactoryWithAppConfig(\n                lambda config: Redis.from_url(config.REDIS_URL, decode_responses=False)\n            ),\n            after_interceptors=True,\n        ),\n        # Authentication configuration\n        ProviderSpec(\n            provide=Token(AuthConfig, \"AUTH_CONFIG\"),\n            use_value=AuthConfig(\n                secret=\"your-secret-key\",\n                identity_refresh_token_expires_delta_seconds=60 * 60 * 24 * 30,\n                identity_token_expires_delta_seconds=60 * 60,\n            ),\n        ),\n        # Token blacklist service for JWT management\n        ProviderSpec(\n            provide=TokenBlackListService,\n            use_value=InMemoryTokenBlackListService(),\n        ),\n    ],\n    controllers=[\n        TasksController,  # Your application controllers\n    ],\n    interceptors=[\n        # Application configuration interceptor\n        AppConfigurationInterceptor(\n            global_configs=[\n                (Token(AppConfig, \"APP_CONFIG\"), AppConfig),\n            ]\n        ),\n        # Message bus interceptor for RabbitMQ\n        AppFactoryWithAppConfig(\n            lambda config: MessageBusPublisherInterceptor(\n                connection_factory=AIOPikaConnectionFactory(\n                    url=config.AMQP_URL,\n                    exchange=\"jararaca_ex\",\n                ),\n            )\n        ),\n        # Database session interceptor\n        AppFactoryWithAppConfig(\n            lambda config: AIOSqlAlchemySessionInterceptor(\n                AIOSQAConfig(\n                    connection_name=\"default\",\n                    url=config.DATABASE_URL,\n                )\n            )\n        ),\n        # WebSocket interceptor\n        AppFactoryWithAppConfig(\n            lambda config: WebSocketInterceptor(\n                backend=RedisWebSocketConnectionBackend(\n                    send_pubsub_channel=\"jararaca:websocket:send\",\n                    broadcast_pubsub_channel=\"jararaca:websocket:broadcast\",\n                    conn=Redis.from_url(config.REDIS_URL, decode_responses=False),\n                )\n            ),\n        ),\n    ],\n)\n\n# Create FastAPI application\nhttp_app = create_http_server(\n    HttpMicroservice(\n        app=app,\n        factory=fastapi_factory,\n    )\n)\n</code></pre>"},{"location":"#core-concepts","title":"Core Concepts","text":""},{"location":"#controllers","title":"Controllers","text":"<p>Controllers are the heart of your microservice. They handle HTTP requests, WebSocket connections, and message bus events. Here's an example of a task controller:</p> <pre><code>@MessageBusController()\n@RestController(\"/tasks\")\nclass TasksController:\n    @Post(\"/\")\n    async def create_task(self, task: CreateTaskSchema) -&gt; Identifiable[TaskSchema]:\n        # Your implementation here\n        pass\n\n    @Get(\"/\")\n    async def get_tasks(self) -&gt; List[TaskSchema]:\n        # Your implementation here\n        pass\n</code></pre>"},{"location":"#entities","title":"Entities","text":"<p>Entities represent your database models. They can be automatically mapped to and from Pydantic models:</p> <pre><code>class TaskEntity(IdentifiableEntity, DatedEntity):\n    __tablename__ = \"tasks\"\n\n    status: Mapped[Literal[\"PENDING\", \"RUNNING\", \"FINISHED\", \"ERROR\"]]\n    extraction_model_id: Mapped[UUID]\n    # ... other fields\n</code></pre>"},{"location":"#query-operations","title":"Query Operations","text":"<p>Jararaca provides powerful query operations with support for pagination and filtering:</p> <pre><code>class TaskSimpleFilter(PaginatedFilter, DateOrderedFilter):\n    pass\n\n@Get(\"/\")\nasync def get_tasks(self, filter: TaskSimpleFilter) -&gt; Paginated[TaskSchema]:\n    return await self.tasks_query_operations.query(filter)\n</code></pre>"},{"location":"#messaging-and-real-time-communication","title":"Messaging and Real-Time Communication","text":"<p>Jararaca provides powerful abstractions for both asynchronous messaging (via message bus) and real-time communication (via WebSockets).</p>"},{"location":"#message-bus-communication","title":"Message Bus Communication","text":"<p>The <code>Message</code> class is the foundation for all message bus communication in Jararaca. Messages can be tasks or events that flow through your microservice architecture.</p> <pre><code>from pydantic import Field\n\nfrom jararaca import Message\n\n\nclass UserCreatedMessage(Message):\n    MESSAGE_TOPIC = \"user.created\"\n    MESSAGE_TYPE = \"event\"  # or \"task\"\n\n    user_id: str\n    username: str\n    email: str\n</code></pre>"},{"location":"#publishing-messages","title":"Publishing Messages","text":"<p>You can publish messages in two ways:</p> <ol> <li>Using the message's built-in <code>publish()</code> method:</li> </ol> <pre><code>user_message = UserCreatedMessage(\n    user_id=\"123\",\n    username=\"johndoe\",\n    email=\"john@example.com\"\n)\nawait user_message.publish()  # Uses the MESSAGE_TOPIC defined in the class\n</code></pre> <ol> <li>Using the publisher directly:</li> </ol> <pre><code>from jararaca import use_publisher\n\npublisher = use_publisher()\nawait publisher.publish(user_message, \"custom.topic\")  # Override the default topic\n</code></pre>"},{"location":"#consuming-messages","title":"Consuming Messages","text":"<p>To consume messages, create a handler with the <code>@MessageHandler</code> decorator:</p> <pre><code>from jararaca import Message, MessageBusController, MessageHandler\n\n@MessageBusController()\nclass UserEventsController:\n    @MessageHandler(\"user.created\")\n    async def handle_user_created(self, message: MessageOf[UserCreatedMessage]):\n        user_data = message.payload()\n        # Process the message\n        print(f\"User created: {user_data.username}\")\n</code></pre>"},{"location":"#websocket-communication","title":"WebSocket Communication","text":"<p>The <code>WebSocketMessage</code> class enables real-time communication with connected WebSocket clients. It provides a simple way to send messages to specific rooms or broadcast to all clients.</p> <pre><code>from jararaca import WebSocketMessage\nfrom pydantic import Field\n\nclass ChatMessage(WebSocketMessage):\n    MESSAGE_ID = \"chat.message\"\n\n    user_id: str\n    username: str\n    content: str\n    timestamp: str\n</code></pre>"},{"location":"#sending-websocket-messages","title":"Sending WebSocket Messages","text":"<p>You can send WebSocket messages to specific rooms:</p> <pre><code>message = ChatMessage(\n    user_id=\"123\",\n    username=\"johndoe\",\n    content=\"Hello, world!\",\n    timestamp=\"2025-04-17T12:00:00Z\"\n)\n\n# Send to specific rooms\nawait message.send(\"room1\", \"room2\")\n</code></pre>"},{"location":"#manual-websocket-management","title":"Manual WebSocket Management","text":"<p>For more control, you can use the WebSocket manager directly:</p> <pre><code>from jararaca import use_ws_manager\n\n# Get the WebSocket manager\nws_manager = use_ws_manager()\n\n# Add a WebSocket connection to rooms\nawait ws_manager.add_websocket_to_room(websocket, \"room1\")\n\n# Send a message to specific rooms\nawait ws_manager.send([\"room1\", \"room2\"], message)\n\n# Broadcast to all connections\nawait ws_manager.broadcast(message)\n</code></pre>"},{"location":"#websocket-endpoint","title":"WebSocket Endpoint","text":"<p>Create a WebSocket endpoint using the <code>@WebSocketEndpoint</code> decorator:</p> <pre><code>from jararaca import WebSocketEndpoint, RestController\nfrom fastapi import WebSocket\n\n@RestController(\"/ws\")\n@RegisterWebSocketMessage(ChatMessage) # Register the WebSocket message in order to be generated in the ts files\nclass WebSocketController:\n    @WebSocketEndpoint(\"/chat/{room_id}\")\n    async def chat_endpoint(self, websocket: WebSocket, room_id: str):\n        await websocket.accept()\n\n        # Add to room\n        ws_manager = use_ws_manager()\n        await ws_manager.add_websocket_to_room(websocket, room_id)\n\n        try:\n            while True:\n                data = await websocket.receive_text()\n                message = ChatMessage(\n                    user_id=\"123\",\n                    username=\"johndoe\",\n                    content=data,\n                    timestamp=\"2025-04-17T12:00:00Z\"\n                )\n                await message.send(room_id)\n        except:\n            # Remove from room when connection closes\n            await ws_manager.remove_websocket_from_room(websocket, room_id)\n</code></pre>"},{"location":"#integration-between-message-bus-and-websockets","title":"Integration Between Message Bus and WebSockets","text":"<p>One of Jararaca's strengths is the ability to seamlessly integrate message bus events with WebSocket communication, enabling real-time updates from background processes:</p> <pre><code>@MessageBusController()\n@RestController(\"/notifications\")\nclass NotificationController:\n    @MessageHandler(\"user.activity\")\n    async def handle_user_activity(self, message: MessageOf[UserActivityMessage]):\n        user_data = message.payload()\n\n        # Create a WebSocket message\n        notification = ActivityNotification(\n            user_id=user_data.user_id,\n            action=user_data.action,\n            timestamp=user_data.timestamp\n        )\n\n        # Send to user's room\n        await notification.send(f\"user-{user_data.user_id}\")\n</code></pre> <p>This allows you to build truly reactive systems where events processed in background workers can immediately update connected clients through WebSockets.</p>"},{"location":"#advanced-features","title":"Advanced Features","text":""},{"location":"#websocket-support","title":"WebSocket Support","text":"<p>Real-time communication is built-in:</p> <pre><code>@WebSocketEndpoint(\"/ws\")\nasync def ws_endpoint(self, websocket: WebSocket):\n    await websocket.accept()\n    await use_ws_manager().add_websocket(websocket)\n    # Handle WebSocket messages\n</code></pre>"},{"location":"#scheduled-tasks","title":"Scheduled Tasks","text":"<p>Run periodic tasks using cron expressions:</p> <pre><code>@ScheduledAction(\"* * * * * */5\")\nasync def scheduled_task(self):\n    # Your scheduled task implementation\n    pass\n</code></pre>"},{"location":"#message-bus-integration","title":"Message Bus Integration","text":"<p>Publish and consume messages through RabbitMQ:</p> <pre><code>@MessageHandler(TaskSchema)\nasync def process_task(self, message: MessageOf[TaskSchema]):\n    # Process incoming messages\n    pass\n</code></pre>"},{"location":"#configuration","title":"Configuration","text":"<p>Configure your microservice through environment variables or configuration files:</p> <pre><code>class AppConfig(BaseModel):\n    DATABASE_URL: str\n    REDIS_URL: str\n    AMQP_URL: str\n</code></pre>"},{"location":"#best-practices","title":"Best Practices","text":"<ol> <li>Use Dependency Injection: Leverage the DI system for better testability and maintainability</li> <li>Implement Proper Error Handling: Use HTTP exceptions for API errors</li> <li>Use Type Hints: Take advantage of Python's type system for better code quality</li> <li>Follow RESTful Principles: Design your API endpoints following REST conventions</li> </ol>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome! Please feel free to submit a Pull Request.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details.</p>"},{"location":"architecture/","title":"Jararaca Architecture","text":""},{"location":"architecture/#core-concept-unified-runtime-interface","title":"Core Concept: Unified Runtime Interface","text":"<p>Jararaca implements a unified runtime interface that allows different types of applications (REST API, Message Bus Worker, and Scheduler) to share the same utilities and context. This means that utilities like <code>@use_session</code> can be used consistently across different runtime contexts, even though they run as separate processes.</p>"},{"location":"architecture/#runtime-types","title":"Runtime Types","text":"<ol> <li> <p>REST API Runtime</p> </li> <li> <p>Handles HTTP requests and WebSocket connections</p> </li> <li>Executes REST controllers</li> <li> <p>Uses <code>@RestController</code> decorator for route definitions</p> </li> <li> <p>Message Bus Worker Runtime</p> </li> <li> <p>Processes asynchronous messages and events</p> </li> <li>Handles tasks and events through <code>@MessageBusController</code></li> <li> <p>Manages message queues and event processing</p> </li> <li> <p>Scheduler Runtime</p> </li> <li>Executes scheduled tasks at specified intervals</li> <li>Uses <code>@ScheduledAction</code> decorator for task definitions</li> <li>Manages cron-based job execution</li> </ol>"},{"location":"architecture/#application-structure","title":"Application Structure","text":"<p>The application structure follows a hierarchical pattern:</p> <ol> <li> <p>Microservice Declaration</p> </li> <li> <p>Uses <code>@Microservice</code> class for configuration</p> </li> <li>Declares providers, controllers, and interceptors</li> <li>No execution happens at declaration time</li> <li> <p>Configuration is shared across all runtimes</p> </li> <li> <p>Application Implementation</p> </li> <li> <p>REST Controllers (<code>@RestController</code>)</p> <ul> <li>Handle HTTP endpoints</li> <li>Run in REST API runtime</li> <li>Support middleware and dependency injection</li> </ul> </li> <li> <p>Events and Tasks (<code>@MessageBusController</code>)</p> <ul> <li>Handle asynchronous operations</li> <li>Run in Message Bus Worker runtime</li> <li>Support message publishing and consumption</li> </ul> </li> <li> <p>Scheduled Jobs (<code>@ScheduledAction</code>)</p> <ul> <li>Execute at specified intervals</li> <li>Run in Scheduler runtime</li> <li>Support cron-based scheduling</li> </ul> </li> </ol>"},{"location":"architecture/#architecture-diagram","title":"Architecture Diagram","text":"<pre><code>graph LR\n    subgraph \"Runtime Layer\"\n        REST[REST API Runtime]\n        Worker[Message Bus Worker Runtime]\n        Scheduler[Scheduler Runtime]\n    end\n\n    subgraph \"Application Layer\"\n        Microservice[Microservice Declaration]\n        RESTController[REST Controllers]\n        MessageBus[Events &amp; Tasks]\n        ScheduledJobs[Scheduled Jobs]\n    end\n\n    subgraph \"Shared Utilities\"\n        Session[use_session]\n        Publisher[use_publisher]\n        WS[use_ws_manager]\n    end\n\n    Microservice --&gt; REST\n    Microservice --&gt; Worker\n    Microservice --&gt; Scheduler\n\n    REST --&gt; RESTController\n    Worker --&gt; MessageBus\n    Scheduler --&gt; ScheduledJobs\n\n    RESTController --&gt; Session\n    MessageBus --&gt; Session\n    ScheduledJobs --&gt; Session\n\n    RESTController --&gt; Publisher\n    MessageBus --&gt; Publisher\n    ScheduledJobs --&gt; Publisher\n\n    RESTController --&gt; WS\n    MessageBus --&gt; WS\n    ScheduledJobs --&gt; WS\n</code></pre>"},{"location":"architecture/#key-features","title":"Key Features","text":"<ol> <li> <p>Shared Context</p> </li> <li> <p>All runtimes share the same context and utilities</p> </li> <li>Consistent access to services like database sessions</li> <li> <p>Unified dependency injection system</p> </li> <li> <p>Declarative Configuration</p> </li> <li> <p>Configuration is defined once in <code>Microservice</code></p> </li> <li>Runtime-specific settings are handled separately</li> <li> <p>Easy to maintain and modify</p> </li> <li> <p>Process Isolation</p> </li> <li> <p>Each runtime runs as a separate process</p> </li> <li>Clear separation of concerns</li> <li> <p>Independent scaling and deployment</p> </li> <li> <p>Unified Utilities</p> </li> <li>Common utilities like <code>@use_session</code> work across all runtimes</li> <li>Consistent API for database access, message publishing, etc.</li> <li>Reduced code duplication</li> </ol>"},{"location":"architecture/#usage-example","title":"Usage Example","text":"<pre><code>from jararaca import (\n    AIOPikaConnectionFactory,\n    AIOSQAConfig,\n    AIOSqlAlchemySessionInterceptor,\n    AppConfigurationInterceptor,\n    HttpMicroservice,\n    MessageBusPublisherInterceptor,\n    Microservice,\n    ProviderSpec,\n    RedisWebSocketConnectionBackend,\n    Token,\n    WebSocketInterceptor,\n    create_http_server,\n)\n\n\n# Define your application configuration\nclass AppConfig:\n    DATABASE_URL: str\n    REDIS_URL: str\n    AMQP_URL: str\n\n# Create the microservice with all necessary components\napp = Microservice(\n    providers=[\n        ProviderSpec(\n            provide=Token(Redis, \"REDIS\"),\n            use_factory=lambda config: Redis.from_url(config.REDIS_URL, decode_responses=False),\n            after_interceptors=True,\n        ),\n    ],\n    controllers=[\n        TasksController,  # Your controller class\n    ],\n    interceptors=[\n        # Configuration interceptor\n        AppConfigurationInterceptor(\n            global_configs=[\n                (Token(AppConfig, \"APP_CONFIG\"), AppConfig),\n            ]\n        ),\n        # Message bus interceptor\n        AppFactoryWithAppConfig(\n            lambda config: MessageBusPublisherInterceptor(\n                connection_factory=AIOPikaConnectionFactory(\n                    url=config.AMQP_URL,\n                    exchange=\"jararaca_ex\",\n                ),\n            )\n        ),\n        # Database session interceptor\n        AppFactoryWithAppConfig(\n            lambda config: AIOSqlAlchemySessionInterceptor(\n                AIOSQAConfig(\n                    connection_name=\"default\",\n                    url=config.DATABASE_URL,\n                )\n            )\n        ),\n        # WebSocket interceptor\n        AppFactoryWithAppConfig(\n            lambda config: WebSocketInterceptor(\n                backend=RedisWebSocketConnectionBackend(\n                    send_pubsub_channel=\"jararaca:websocket:send\",\n                    broadcast_pubsub_channel=\"jararaca:websocket:broadcast\",\n                    conn=Redis.from_url(config.REDIS_URL, decode_responses=False),\n                )\n            ),\n        ),\n    ],\n)\n\n# Create HTTP server for REST API runtime\nhttp_app = create_http_server(\n    HttpMicroservice(\n        app=app,\n        factory=fastapi_factory,\n    )\n)\n\n\nclass HelloTask(Message):\n    MESSAGE_TYPE = \"task\"\n    MESSAGE_TOPIC = \"task.topic.name\"\n\n    message: str\n\n# Example controller showing unified utilities across runtimes\n@MessageBusController()\n@RestController(\"/tasks\")\nclass TasksController:\n    def __init__(self, redis: Annotated[Redis, Token(Redis, \"REDIS\")]):\n        self.redis = redis\n        self.tasks_crud = CRUDOperations(TaskEntity, use_session)\n\n    @Post(\"/\")\n    async def create_task(self, task: CreateTaskSchema) -&gt; Identifiable[TaskSchema]:\n        # Use session in REST context\n        task_entity = await self.tasks_crud.create(task)\n        await use_ws_manager().broadcast(b\"New Task Created\")\n        await use_publisher().publish(task_entity.to_identifiable(TaskSchema), topic=\"task\")\n        return task_entity.to_identifiable(TaskSchema)\n\n    @MessageHandler(HelloTask)\n    async def process_task(self, message: MessageOf[HelloTask]) -&gt; None:\n        # Use session in Message Bus context\n        print(message.message)\n\n    @ScheduledAction(\"* * * * * */5\")\n    async def scheduled_task(self) -&gt; None:\n        # Use session in Scheduler context\n        pending_tasks = await use_session().execute(select(TaskEntity))\n        for task in pending_tasks:\n            await use_publisher().publish(task.to_identifiable(TaskSchema), topic=\"task\")\n</code></pre>"},{"location":"architecture/#context-hooks-and-interceptors","title":"Context Hooks and Interceptors","text":"<p>Jararaca provides a powerful system of context hooks (like <code>use_session</code>, <code>use_publisher</code>, <code>use_ws_manager</code>) that are managed through Python's <code>ContextVar</code> system. These hooks are configured separately for each execution context and are provided by interceptors configured in the <code>Microservice</code> instance.</p> <p>Important Note on Interceptor Order The order of interceptors in the <code>Microservice</code> instance matters significantly. Interceptors are executed in the order they are defined, meaning:</p> <ul> <li>The first interceptor in the list will set up its context before the subsequent ones</li> <li>This order affects how dependencies between different context hooks are resolved</li> <li>For example, if a database session is needed by a message publisher, the session interceptor should be configured before the publisher interceptor</li> </ul>"},{"location":"architecture/#how-context-hooks-work","title":"How Context Hooks Work","text":"<ol> <li> <p>Context Isolation</p> </li> <li> <p>Each execution (HTTP request, message processing, scheduled job) gets its own isolated context</p> </li> <li>Context hooks provide access to resources specific to that execution</li> <li> <p>Resources are automatically cleaned up when the execution completes</p> </li> <li> <p>Interceptor-Based Provision</p> </li> <li>Interceptors are responsible for setting up and managing the context</li> <li>They are configured in the <code>Microservice</code> instance</li> <li>Each interceptor handles a specific type of resource</li> </ol>"},{"location":"architecture/#example-database-session-management","title":"Example: Database Session Management","text":"<pre><code># The AIOSqlAlchemySessionInterceptor manages database sessions\nclass AIOSqlAlchemySessionInterceptor(AppInterceptor):\n    def __init__(self, config: AIOSQAConfig):\n        self.config = config\n        self.engine = create_async_engine(self.config.url)\n        self.sessionmaker = async_sessionmaker(self.engine)\n\n    @asynccontextmanager\n    async def intercept(self, app_context: AppContext) -&gt; AsyncGenerator[None, None]:\n        # Creates a new session for this execution\n        async with self.sessionmaker() as session:\n            # Provides the session to the context\n            with provide_session(self.config.connection_name, session):\n                try:\n                    yield\n                    await session.commit()\n                except Exception as e:\n                    await session.rollback()\n                    raise e\n</code></pre>"},{"location":"architecture/#context-hook-lifecycle","title":"Context Hook Lifecycle","text":"<ol> <li>Configuration</li> </ol> <pre><code>app = Microservice(\n    interceptors=[\n        AIOSqlAlchemySessionInterceptor(\n            AIOSQAConfig(\n                connection_name=\"default\",\n                url=config.DATABASE_URL,\n            )\n        ),\n        # Other interceptors...\n    ]\n)\n</code></pre> <ol> <li> <p>Execution</p> </li> <li> <p>When a request/message/job starts, interceptors are activated</p> </li> <li>Each interceptor sets up its context using <code>ContextVar</code></li> <li> <p>The context is available throughout the execution</p> </li> <li> <p>Cleanup</p> </li> <li>When execution completes, interceptors clean up resources</li> <li>Context is automatically reset</li> <li>Resources are properly closed/released</li> </ol>"},{"location":"architecture/#available-context-hooks","title":"Available Context Hooks","text":"<ol> <li> <p>Database Sessions (<code>use_session</code>)</p> </li> <li> <p>Provided by <code>AIOSqlAlchemySessionInterceptor</code></p> </li> <li>Creates isolated database sessions per execution</li> <li> <p>Handles transaction management automatically</p> </li> <li> <p>Message Publishing (<code>use_publisher</code>)</p> </li> <li> <p>Provided by <code>MessageBusPublisherInterceptor</code></p> </li> <li>Manages message publishing context</li> <li> <p>Ensures proper message delivery</p> </li> <li> <p>WebSocket Management (<code>use_ws_manager</code>)</p> </li> <li>Provided by <code>WebSocketInterceptor</code></li> <li>Handles WebSocket connections and broadcasting</li> <li>Manages connection state</li> </ol>"},{"location":"architecture/#usage-in-different-contexts","title":"Usage in Different Contexts","text":"<pre><code># In a REST Controller\n@RestController(\"/tasks\")\n@MessageBusController()\nclass TasksController:\n    @Get(\"/\")\n    async def get_tasks(self):\n        # Gets a session specific to this HTTP request\n        session = use_session()\n        return await session.execute(select(TaskEntity))\n\n\n    @MessageHandler(SomeTask)\n    async def process_task(self, message: MessageOf[SomeTask]):\n        # Gets a session specific to this message processing\n        session = use_session()\n\n    # In a Scheduled Job\n    @ScheduledAction(\"* * * * *\")\n    async def scheduled_task(self):\n        # Gets a session specific to this job execution\n        session = use_session()\n        await session.execute(select(TaskEntity))\n</code></pre> <p>This system ensures that:</p> <ul> <li>Each execution has its own isolated resources</li> <li>Resources are properly managed and cleaned up</li> <li>The same utilities can be used consistently across different runtime contexts</li> <li>Dependencies are properly injected and managed</li> </ul>"},{"location":"architecture/#graceful-shutdown-handling","title":"Graceful Shutdown Handling","text":"<p>Jararaca provides a unified shutdown handling system that works across all runtime types (HTTP server, worker, scheduler). This allows applications to gracefully handle shutdown signals and clean up resources properly.</p>"},{"location":"architecture/#shutdown-utilities","title":"Shutdown Utilities","text":"<ol> <li><code>shutdown_race(*coroutines)</code> - Race coroutines against shutdown signals</li> </ol> <pre><code>from jararaca import shutdown_race\n\nasync def long_running_task():\n    # Your long-running logic\n    await asyncio.sleep(60)\n\n# Returns True if shutdown was requested, False if the task completed\nwas_shutdown = await shutdown_race(long_running_task())\nif was_shutdown:\n    print(\"Task was interrupted by shutdown\")\nelse:\n    print(\"Task completed normally\")\n</code></pre> <ol> <li><code>wait_for_shutdown()</code> - Block until shutdown is requested</li> </ol> <pre><code>from jararaca import wait_for_shutdown\n\nasync def background_service():\n    while True:\n        # Do some work\n        await do_work()\n        # Wait for next iteration or shutdown\n        if await shutdown_race(asyncio.sleep(5)):\n            break\n</code></pre> <ol> <li><code>is_shutting_down()</code> - Check if shutdown has been requested</li> </ol> <pre><code>from jararaca import is_shutting_down\n\nasync def processing_loop():\n    while not is_shutting_down():\n        await process_next_item()\n</code></pre> <ol> <li><code>request_shutdown()</code> - Programmatically trigger shutdown</li> </ol> <pre><code>from jararaca import request_shutdown\n\nasync def critical_error_handler():\n    # Something went wrong, request graceful shutdown\n    request_shutdown()\n</code></pre>"},{"location":"architecture/#usage-patterns","title":"Usage Patterns","text":"<p>Long-running background tasks:</p> <pre><code>@MessageBusController()\nclass BackgroundWorker:\n    @MessageHandler(ProcessBatchTask)\n    async def process_batch(self, message: MessageOf[ProcessBatchTask]) -&gt; None:\n        for item in message.items:\n            if is_shutting_down():\n                # Save progress and exit gracefully\n                await self.save_checkpoint(item)\n                return\n            await self.process_item(item)\n</code></pre> <p>Waiting with timeout or shutdown:</p> <pre><code>async def wait_for_resource_with_shutdown(resource_id: str):\n    was_shutdown = await shutdown_race(\n        wait_for_resource(resource_id),\n        asyncio.sleep(30)  # timeout\n    )\n    if was_shutdown:\n        raise ShutdownInterrupt(\"Operation cancelled due to shutdown\")\n</code></pre> <p>The shutdown system is automatically integrated into Jararaca's CLI commands (<code>jararaca server</code>, <code>jararaca worker</code>, <code>jararaca beat</code>), handling SIGINT and SIGTERM signals gracefully.</p>"},{"location":"example-app/","title":"Example Application","text":"<p>This section provides a complete example of a Jararaca microservice application, demonstrating key features such as:</p> <ul> <li>Dependency Injection: Wiring up services and clients.</li> <li>HTTP RPC Client: Defining and using a type-safe REST client.</li> <li>Controllers: Implementing REST endpoints with decorators.</li> <li>Middleware: Using middleware for authentication and request processing.</li> <li>Observability: Integrating OpenTelemetry for tracing.</li> <li>Pydantic Models: Defining data schemas.</li> </ul>"},{"location":"example-app/#project-structure","title":"Project Structure","text":"<p>The example application consists of the following files:</p> <pre><code>examples/\n\u251c\u2500\u2500 app.py          # Main application entry point and configuration\n\u251c\u2500\u2500 client.py       # HTTP RPC client definition\n\u251c\u2500\u2500 controller.py   # Controller implementation\n\u2514\u2500\u2500 schemas.py      # Pydantic data models\n</code></pre>"},{"location":"example-app/#1-schemas-schemaspy","title":"1. Schemas (<code>schemas.py</code>)","text":"<p>First, we define the data models using Pydantic. These models are used for both request and response bodies.</p> <pre><code>from pydantic import BaseModel\n\n\nclass HelloResponse(BaseModel):\n    message: str\n</code></pre>"},{"location":"example-app/#2-client-clientpy","title":"2. Client (<code>client.py</code>)","text":"<p>Next, we define the interface for an external service (or even our own service) using the HTTP RPC client system. This allows us to make type-safe HTTP requests.</p> <pre><code>from typing import Protocol, runtime_checkable\n\nfrom examples.schemas import HelloResponse\nfrom jararaca import Body, Get, Post, Query, RestClient\n\n\n@RestClient(\"/my\")\n@runtime_checkable\nclass HelloRPC(Protocol):\n\n    @Get(\"/hello\")\n    @Query(\"gather\")\n    async def my_hello(self, gather: bool) -&gt; HelloResponse: ...\n\n    @Get(\"/ping\")\n    async def ping(self) -&gt; HelloResponse: ...\n\n    @Post(\"/create-response\")\n    @Body(\"response\")\n    async def create_response(self, response: HelloResponse) -&gt; HelloResponse: ...\n</code></pre>"},{"location":"example-app/#3-controller-controllerpy","title":"3. Controller (<code>controller.py</code>)","text":"<p>The controller implements the API endpoints. It uses the <code>HelloRPC</code> client (injected via DI) to perform some logic. It also demonstrates the use of middleware and observability decorators.</p> <pre><code>import asyncio\nimport logging\nimport os\nimport random\nfrom typing import Annotated, Any, AsyncGenerator\n\nfrom fastapi import Request\nfrom fastapi.params import Header, Query\nfrom opentelemetry import metrics\n\nfrom examples.client import HelloRPC\nfrom examples.schemas import HelloResponse\nfrom jararaca import (\n    Get,\n    HttpMiddleware,\n    Post,\n    RestController,\n    Token,\n    TracedFunc,\n    UseMiddleware,\n)\n\nlogger = logging.getLogger(__name__)\n\n\nmeter = metrics.get_meter(__name__)\nhello_counter = meter.create_counter(\n    \"hello_counter\",\n    unit=\"1\",\n    description=\"Counts number of hello for each pid\",\n)\n\n\nclass HelloService:\n    def __init__(\n        self,\n        hello_rpc: Annotated[HelloRPC, Token(HelloRPC, \"HELLO_RPC\")],\n    ):\n        self.hello_rpc = hello_rpc\n\n    @TracedFunc(\"ping\")\n    async def ping(self) -&gt; HelloResponse:\n        return await self.hello_rpc.ping()\n\n    @TracedFunc(\"hello-service\")\n    async def hello(\n        self,\n        gather: bool,\n    ) -&gt; HelloResponse:\n\n        now = asyncio.get_event_loop().time()\n        if gather:\n            await asyncio.gather(*[self.random_await(a) for a in range(10)])\n        else:\n            for a in range(10):\n                await self.random_await(a)\n        return HelloResponse(\n            message=\"Elapsed time: {}\".format(asyncio.get_event_loop().time() - now)\n        )\n\n    @TracedFunc(\"random-await\")\n    async def random_await(self, index: int) -&gt; None:\n        logger.info(\"Random await %s\", index, extra={\"index\": index})\n        await asyncio.sleep(random.randint(1, 3))\n        logger.info(\"Random await %s done\", index, extra={\"index\": index})\n\n\nclass AuthMiddleware(HttpMiddleware):\n\n    async def intercept(\n        self,\n        api_key: Annotated[str, Header(alias=\"X-API-Key\")],\n        user_id: Annotated[str, Query()],\n    ) -&gt; AsyncGenerator[None, Any]:\n        logger.info(\"AuthMiddleware - API Key: %s, User ID: %s\", api_key, user_id)\n        yield\n\n\nclass AdminMiddleware(HttpMiddleware):\n\n    async def intercept(\n        self,\n        admin_token: Annotated[str, Header(alias=\"X-Admin-Token\")],\n    ) -&gt; AsyncGenerator[None, Any]:\n        logger.info(\"AdminMiddleware - Admin Token: %s\", admin_token)\n        yield\n\n\nclass UserAccessMiddleware(HttpMiddleware):\n    \"\"\"\n    Middleware that checks user access using user_id from the path parameter.\n    This demonstrates how middleware can access path parameters.\n    \"\"\"\n\n    async def intercept(\n        self,\n        user_id: str,  # This will be detected as a path parameter if {user_id} is in the path\n        access_level: Annotated[str, Header(alias=\"X-Access-Level\")],\n    ) -&gt; AsyncGenerator[None, Any]:\n        logger.info(\n            \"UserAccessMiddleware - User ID: %s, Access Level: %s\",\n            user_id,\n            access_level,\n        )\n        yield\n\n\n@RestController(\n    \"/my\",\n    middlewares=[AuthMiddleware],\n)\n@UseMiddleware(AdminMiddleware)  # Class-level UseMiddleware decorator\nclass MyController:\n\n    def __init__(\n        self,\n        hello_service: HelloService,\n    ) -&gt; None:\n        self.hello_service = hello_service\n\n    @TracedFunc(\"hello\")\n    @Get(\"/hello\")\n    async def hello(self, gather: bool, request: Request) -&gt; HelloResponse:\n        hello_counter.add(1, {\"pid\": str(os.getpid())})\n\n        logger.info(\"Hello %s\", request.query_params.get(\"name\") or \"World\")\n        res = await self.hello_service.ping()\n        return res\n\n    @TracedFunc(\"ping\")\n    @Get(\"/ping\")\n    async def ping(self) -&gt; HelloResponse:\n        return HelloResponse(message=\"pong\")\n\n    @TracedFunc(\"create-response\")\n    @Post(\"/create-response\")\n    @UseMiddleware(\n        UserAccessMiddleware\n    )  # Method-level UseMiddleware (will also get class-level AdminMiddleware)\n    async def create_response(self, hello_response: HelloResponse) -&gt; HelloResponse:\n        return hello_response\n\n\n@RestController(\n    \"/users/{user_id}\",  # This path contains a user_id parameter\n    middlewares=[\n        UserAccessMiddleware\n    ],  # Middleware can access the user_id path parameter\n)\nclass UserController:\n    \"\"\"\n    Controller that demonstrates middleware accessing path parameters.\n    The UserAccessMiddleware will have access to the user_id path parameter.\n    \"\"\"\n\n    @Get(\"/profile\")\n    async def get_user_profile(self, user_id: str) -&gt; dict[str, str]:\n        return {\"user_id\": user_id, \"profile\": \"user profile data\"}\n\n    @Post(\"/settings\")\n    async def update_user_settings(\n        self, user_id: str, settings: dict[str, Any]\n    ) -&gt; dict[str, Any]:\n        return {\"user_id\": user_id, \"settings\": settings}\n</code></pre>"},{"location":"example-app/#4-application-apppy","title":"4. Application (<code>app.py</code>)","text":"<p>Finally, we wire everything together in the main application file. We configure the <code>Microservice</code> with providers (for DI), controllers, and interceptors (for observability).</p> <pre><code>import logging\nimport os\n\nfrom examples.client import HelloRPC\nfrom examples.controller import MyController\nfrom jararaca import (\n    HttpMicroservice,\n    HttpRpcClientBuilder,\n    HTTPXHttpRPCAsyncBackend,\n    Microservice,\n    ObservabilityInterceptor,\n    OtelObservabilityProvider,\n    ProviderSpec,\n    Token,\n    TracedRequestMiddleware,\n    create_http_server,\n)\n\nlogger = logging.getLogger(__name__)\n\n\napp = Microservice(\n    providers=[\n        ProviderSpec(\n            provide=Token(HelloRPC, \"HELLO_RPC\"),\n            use_value=HttpRpcClientBuilder(\n                HTTPXHttpRPCAsyncBackend(prefix_url=\"http://localhost:8000\"),\n                middlewares=[TracedRequestMiddleware()],\n            ).build(\n                HelloRPC  # type: ignore[type-abstract]\n            ),\n        )\n    ],\n    controllers=[MyController],\n    interceptors=[\n        ObservabilityInterceptor(\n            OtelObservabilityProvider.from_url(\n                \"App-example\",\n                url=os.getenv(\"OTEL_ENDPOINT\", \"localhost\"),\n            )\n        )\n    ],\n)\n\n\nhttp_app = create_http_server(HttpMicroservice(app))\n\n\nloggers = logging.root.manager.loggerDict.get(\"examples\")\n\nif isinstance(loggers, logging.PlaceHolder):\n\n    for logger_name in loggers.loggerMap.keys():\n        formatter = logging.Formatter(\n            \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n        )\n        stream_handler = logging.StreamHandler()\n        stream_handler.setFormatter(formatter)\n        logger_name.addHandler(stream_handler)\n        logger_name.setLevel(logging.DEBUG)\n</code></pre>"},{"location":"example-app/#running-the-application","title":"Running the Application","text":"<p>To run this example application, you can use the <code>jararaca server</code> command. Note that we point to the <code>Microservice</code> instance (<code>app</code>), not the <code>FastAPI</code> app (<code>http_app</code>).</p> <pre><code>jararaca server examples.app:app --port 8081\n</code></pre> <p>Output: <pre><code>INFO:     Started server process [12345]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.\nINFO:     Uvicorn running on http://0.0.0.0:8081 (Press CTRL+C to quit)\n</code></pre></p> <p>Or if you want to run it with <code>uvicorn</code> directly (pointing to the <code>FastAPI</code> app):</p> <pre><code>uvicorn examples.app:http_app --reload\n</code></pre> <p>Once running, you can access the API documentation at <code>http://localhost:8081/docs</code>.</p>"},{"location":"example-app/#generating-typescript-interfaces","title":"Generating TypeScript Interfaces","text":"<p>You can generate TypeScript interfaces for the client application using the <code>gen-tsi</code> command:</p> <pre><code>jararaca gen-tsi examples.app:app --stdout\n</code></pre> <p>This will output the generated TypeScript code, including interfaces for your models and a client class for your controller:</p> <pre><code>/* eslint-disable */\n// @ts-nocheck\n// noinspection JSUnusedGlobalSymbols\n\nimport \"@jararaca/core\"\nimport createClassInfiniteQueryHooks\nimport createClassMutationHooks\nimport createClassQueryHooks\nimport HttpBackend\nimport HttpBackendRequest\nimport paginationModelByFirstArgPaginationFilter\nimport recursiveCamelToSnakeCase }\nimport ResponseType\nimport { HttpService\n\n// ... helper functions ...\n\nexport interface HelloResponse {\n  message: string;\n}\n\nexport class MyController extends HttpService {\n    async createResponse(api_key: string, user_id: string, admin_token: string, user_id: string, access_level: string, hello_response: HelloResponse): Promise&lt;HelloResponse&gt; {\n        const response = await this.httpBackend.request&lt;HelloResponse&gt;({\n            method: \"POST\",\n            path: `/my/create-response`,\n            pathParams: {\n            },\n            headers: {\n                \"access_level\": access_level,\n                \"admin_token\": admin_token,\n                \"api_key\": api_key,\n            },\n            query: {\n                \"user_id\": user_id,\n                \"user_id\": user_id,\n            },\n            body: hello_response\n        });\n        return response;\n    }\n\n    async hello(api_key: string, user_id: string, admin_token: string, gather: boolean): Promise&lt;HelloResponse&gt; {\n        const response = await this.httpBackend.request&lt;HelloResponse&gt;({\n            method: \"GET\",\n            path: `/my/hello`,\n            pathParams: {\n            },\n            headers: {\n                \"admin_token\": admin_token,\n                \"api_key\": api_key,\n            },\n            query: {\n                \"gather\": gather,\n                \"user_id\": user_id,\n            },\n            body: undefined\n        });\n        return response;\n    }\n\n    async ping(api_key: string, user_id: string, admin_token: string): Promise&lt;HelloResponse&gt; {\n        const response = await this.httpBackend.request&lt;HelloResponse&gt;({\n            method: \"GET\",\n            path: `/my/ping`,\n            pathParams: {\n            },\n            headers: {\n                \"admin_token\": admin_token,\n                \"api_key\": api_key,\n            },\n            query: {\n                \"user_id\": user_id,\n            },\n            body: undefined\n        });\n        return response;\n    }\n}\n</code></pre>"},{"location":"expose-type/","title":"Exposing Types for TypeScript Generation","text":"<p>The <code>@ExposeType</code> decorator allows you to explicitly expose types for TypeScript interface generation without requiring them to be directly referenced in REST endpoints, WebSocket messages, or as indirect dependencies.</p>"},{"location":"expose-type/#use-cases","title":"Use Cases","text":"<p>The <code>@ExposeType</code> decorator is useful when you have types that:</p> <ol> <li>Are used only on the frontend - Types that exist for frontend state management, validation, or business logic</li> <li>Are part of a shared schema - Common types that multiple parts of your application use but aren't directly in API contracts</li> <li>Need to be pre-generated - Types that you want available immediately even if they're not yet used in any endpoints</li> <li>Are utility types - Helper types, enums, or constants that the frontend needs to know about</li> </ol>"},{"location":"expose-type/#basic-usage","title":"Basic Usage","text":"<p>Simply decorate any Pydantic model with <code>@ExposeType()</code>:</p> <pre><code>from pydantic import BaseModel\n\nfrom jararaca import ExposeType\n\n\n@ExposeType()\nclass UserPermission(BaseModel):\n    id: str\n    name: str\n    description: str\n    resource: str\n    action: str\n</code></pre> <p>This type will now be included in the generated TypeScript output when you run:</p> <pre><code>jararaca gen-tsi app:app output.ts\n</code></pre>"},{"location":"expose-type/#example-frontend-only-types","title":"Example: Frontend-Only Types","text":"<pre><code>from pydantic import BaseModel\n\nfrom jararaca import ExposeType\n\n\n@ExposeType()\nclass FilterState(BaseModel):\n    \"\"\"Frontend state for table filtering.\"\"\"\n    search_query: str\n    sort_column: str\n    sort_direction: str\n    page: int\n    page_size: int\n\n@ExposeType()\nclass UITheme(BaseModel):\n    \"\"\"Frontend theme configuration.\"\"\"\n    primary_color: str\n    secondary_color: str\n    dark_mode: bool\n</code></pre>"},{"location":"expose-type/#example-error-codes-and-constants","title":"Example: Error Codes and Constants","text":"<pre><code>from enum import Enum\n\nfrom pydantic import BaseModel\n\nfrom jararaca import ExposeType\n\n\n@ExposeType()\nclass ErrorCode(str, Enum):\n    \"\"\"Standard error codes.\"\"\"\n    UNAUTHORIZED = \"UNAUTHORIZED\"\n    NOT_FOUND = \"NOT_FOUND\"\n    VALIDATION_ERROR = \"VALIDATION_ERROR\"\n    INTERNAL_ERROR = \"INTERNAL_ERROR\"\n\n@ExposeType()\nclass ApiErrorDetail(BaseModel):\n    \"\"\"Detailed error information.\"\"\"\n    code: ErrorCode\n    message: str\n    field: str | None = None\n    details: dict[str, str] | None = None\n</code></pre>"},{"location":"expose-type/#example-complex-nested-types","title":"Example: Complex Nested Types","text":"<pre><code>from pydantic import BaseModel\n\nfrom jararaca import ExposeType\n\n\n@ExposeType()\nclass Address(BaseModel):\n    street: str\n    city: str\n    country: str\n    postal_code: str\n\n@ExposeType()\nclass ContactInfo(BaseModel):\n    email: str\n    phone: str | None = None\n    address: Address\n\n@ExposeType()\nclass Organization(BaseModel):\n    \"\"\"Complete organization structure.\"\"\"\n    id: str\n    name: str\n    contacts: list[ContactInfo]\n    settings: dict[str, str]\n</code></pre> <p>When you expose a type with nested structures, the decorator ensures that all related types are also included in the TypeScript generation.</p>"},{"location":"expose-type/#comparison-with-vs-without-exposetype","title":"Comparison: With vs Without @ExposeType","text":""},{"location":"expose-type/#without-exposetype","title":"Without @ExposeType","text":"<pre><code>class UserRole(BaseModel):\n    \"\"\"Only generated if used in an endpoint or as a dependency.\"\"\"\n    id: str\n    name: str\n\n@RestController(\"/api/users\")\nclass UserController:\n    @Get(\"/{user_id}\")\n    async def get_user(self, user_id: str) -&gt; UserResponse:\n        # UserRole is only generated if UserResponse references it\n        return UserResponse(...)\n</code></pre>"},{"location":"expose-type/#with-exposetype","title":"With @ExposeType","text":"<pre><code>@ExposeType()\nclass UserRole(BaseModel):\n    \"\"\"Always generated, available immediately.\"\"\"\n    id: str\n    name: str\n\n@RestController(\"/api/users\")\nclass UserController:\n    @Get(\"/{user_id}\")\n    async def get_user(self, user_id: str) -&gt; UserResponse:\n        # UserRole is available in TypeScript even if not used yet\n        return UserResponse(...)\n</code></pre>"},{"location":"expose-type/#integration-with-other-decorators","title":"Integration with Other Decorators","text":"<p>The <code>@ExposeType</code> decorator works seamlessly with other TypeScript generation decorators:</p> <pre><code>from jararaca import ExposeType, SplitInputOutput\n\n\n@ExposeType()\n@SplitInputOutput()\nclass UserProfile(BaseModel):\n    \"\"\"Generates UserProfileInput and UserProfileOutput interfaces.\"\"\"\n    id: str\n    username: str\n    email: str\n    created_at: str\n    updated_at: str\n</code></pre> <p>This creates both <code>UserProfileInput</code> and <code>UserProfileOutput</code> TypeScript interfaces.</p>"},{"location":"expose-type/#best-practices","title":"Best Practices","text":"<ol> <li>Use for shared types: Apply <code>@ExposeType</code> to types that are used across multiple parts of your application</li> <li>Document the purpose: Add clear docstrings explaining why a type is exposed</li> <li>Avoid overuse: Only expose types that the frontend actually needs - don't expose internal implementation details</li> <li>Combine with other decorators: Use alongside <code>@SplitInputOutput</code> when appropriate</li> <li>Group related types: Keep exposed types in dedicated modules (e.g., <code>shared_types.py</code>)</li> </ol>"},{"location":"expose-type/#viewing-exposed-types","title":"Viewing Exposed Types","text":"<p>All types decorated with <code>@ExposeType</code> are tracked globally. You can check which types are exposed:</p> <pre><code>from jararaca.tools.typescript.decorators import ExposeType\n\n# Get all exposed types\nexposed = ExposeType.get_all_exposed_types()\nprint(f\"Exposed {len(exposed)} types: {[t.__name__ for t in exposed]}\")\n</code></pre>"},{"location":"expose-type/#generated-typescript","title":"Generated TypeScript","text":"<p>Given this Python code:</p> <pre><code>@ExposeType()\nclass NotificationPreference(BaseModel):\n    email_enabled: bool\n    push_enabled: bool\n    frequency: str\n</code></pre> <p>The generated TypeScript will be:</p> <pre><code>export interface NotificationPreference {\n  emailEnabled: boolean;\n  frequency: string;\n  pushEnabled: boolean;\n}\n</code></pre> <p>The type is available in your TypeScript code even if no REST endpoint uses it yet.</p>"},{"location":"expose-type/#full-example","title":"Full Example","text":"<p>You can find a complete example in <code>examples/full_expose_example.py</code>. To generate the TypeScript interfaces for this example, run:</p> <pre><code>jararaca gen-tsi examples.full_expose_example:app --stdout\n</code></pre> <p>This will output:</p> <pre><code>/* eslint-disable */\n// @ts-nocheck\n// noinspection JSUnusedGlobalSymbols\n\nimport { HttpService, HttpBackend, HttpBackendRequest, ResponseType, createClassQueryHooks , createClassMutationHooks, createClassInfiniteQueryHooks, paginationModelByFirstArgPaginationFilter, recursiveCamelToSnakeCase } from \"@jararaca/core\";\n\n// ... helper functions ...\n\nexport interface NotificationPreference {\n  emailEnabled: boolean;\n  frequency: string;\n  pushEnabled: boolean;\n  smsEnabled: boolean;\n}\nexport interface ThemeSettings {\n  accentColor: string;\n  darkMode: boolean;\n  fontSize: string;\n  primaryColor: string;\n}\nexport interface UserListResponse {\n  page: number;\n  pageSize: number;\n  total: number;\n  users: Array&lt;UserProfile&gt;;\n}\nexport interface UserPermissionSet {\n  canAdmin: boolean;\n  canDelete: boolean;\n  canRead: boolean;\n  canWrite: boolean;\n  resourceType: string;\n}\nexport interface UserProfileInput {\n  avatarUrl?: string | null;\n  displayName?: string | null;\n  email: string;\n  id: string;\n  username: string;\n}\nexport interface UserProfileOutput {\n  avatarUrl: string | null;\n  displayName: string | null;\n  email: string;\n  id: string;\n  username: string;\n}\nexport class UserController extends HttpService {\n    async listUsers(page: number, page_size: number): Promise&lt;UserListResponse&gt; {\n        const response = await this.httpBackend.request&lt;UserListResponse&gt;({\n            method: \"GET\",\n            path: `/api/users`,\n            pathParams: {\n            },\n            headers: {\n            },\n            query: {\n                \"page\": page,\n                \"page_size\": page_size,\n            },\n            body: undefined\n        });\n        return response;\n    }\n}\n</code></pre>"},{"location":"http-middleware/","title":"HTTP Request Context Management","text":"<p>Jararaca provides Unit of Work (UoW) context management for HTTP requests, ensuring that database transactions, message publishing, and WebSocket communications are handled atomically. This document covers how the UoW context system works and how to use it.</p>"},{"location":"http-middleware/#overview","title":"Overview","text":"<p>The UoW context ensures that: - Database transactions are properly scoped to requests - Messages are only published if the database transaction succeeds (transactional outbox pattern) - WebSocket messages are dispatched after successful database commits - All operations within a request share the same transaction context</p>"},{"location":"http-middleware/#current-implementation-httpuowcontextproviderdependency","title":"Current Implementation: HttpUowContextProviderDependency","text":"<p>Jararaca currently implements UoW context management using FastAPI's dependency injection system through the <code>HttpUowContextProviderDependency</code> class.</p> <pre><code>from fastapi import Depends\nfrom jararaca import HttpMicroservice, create_http_server\nfrom jararaca.presentation.server import HttpUowContextProviderDependency\n\n# The create_http_server function automatically sets up the UoW context\nhttp_app = HttpMicroservice(app=app)\nfastapi_app = create_http_server(http_app)\n\n# Under the hood, it does this:\nuow_provider = UnitOfWorkContextProvider(app, container)\nuow_dependency = HttpUowContextProviderDependency(uow_provider)\n\nfastapi_app.router.dependencies.append(\n    Depends(uow_dependency)\n)\n</code></pre> <p>The <code>HttpUowContextProviderDependency</code> automatically: 1. Extracts endpoint metadata from the request 2. Sets up the UoW context with all configured interceptors 3. Manages the transaction boundary 4. Handles errors and converts them to appropriate HTTP responses</p>"},{"location":"http-middleware/#request-lifecycle","title":"Request Lifecycle","text":"<p>When a request comes in, the following happens:</p> <ol> <li>Request Received \u2192 FastAPI invokes the dependency</li> <li>Context Setup \u2192 <code>HttpUowContextProviderDependency</code> sets up the UoW context</li> <li>Interceptors Activated \u2192 All configured interceptors are invoked in order:</li> <li>Configuration Interceptor (if any)</li> <li>Message Bus Publisher Interceptor (stages messages)</li> <li>Database Session Interceptor (begins transaction)</li> <li>WebSocket Interceptor (stages WebSocket messages)</li> <li>Handler Execution \u2192 Your controller method executes</li> <li>Commit Phase \u2192 Interceptors commit in reverse order:</li> <li>Database commits first</li> <li>Messages are published (only if DB commit succeeded)</li> <li>WebSocket messages are dispatched</li> <li>Response Returned \u2192 FastAPI sends the response</li> </ol>"},{"location":"http-middleware/#error-handling","title":"Error Handling","text":"<p>The dependency automatically handles errors:</p> <pre><code>try:\n    # Your endpoint code executes\n    yield\nexcept HTTPException:\n    # FastAPI's HTTP exceptions pass through\n    raise\nexcept Exception as e:\n    # Other exceptions become 500 Internal Server Error\n    logger.exception(\"Unhandled exception in request handling.\")\n    raise HTTPException(\n        status_code=500,\n        detail={\n            \"message\": \"Internal server error occurred.\",\n            \"x-traceparentid\": response.headers.get(\"traceparent\")\n        }\n    ) from e\n</code></pre>"},{"location":"http-middleware/#websocket-support","title":"WebSocket Support","text":"<p>The same system works for WebSocket connections:</p> <pre><code>@RestController(\"/ws\")\nclass WebSocketController:\n    @WebSocketEndpoint(\"/chat\")\n    async def chat_endpoint(self, websocket: WebSocket) -&gt; None:\n        # The UoW context is automatically available\n        # You can use use_session(), use_publisher(), etc.\n        pass\n</code></pre> <p>The <code>HttpUowContextProviderDependency</code> detects whether it's handling an HTTP request or WebSocket connection and sets up the appropriate context.</p>"},{"location":"http-middleware/#usage-in-controllers","title":"Usage in Controllers","text":"<p>Once the UoW context is set up, you can use context hooks anywhere in your code:</p> <pre><code>from jararaca import RestController, Post, use_session, use_publisher\n\n@RestController(\"/api/users\")\nclass UserController:\n    @Post(\"/\")\n    async def create_user(self, user_data: dict) -&gt; dict:\n        # Access the database session\n        session = use_session()\n\n        # Create user\n        user = User(**user_data)\n        session.add(user)\n\n        # Stage a message for publishing\n        publisher = use_publisher()\n        await publisher.publish(UserCreatedEvent(user_id=user.id))\n\n        # Transaction commits and message publishes automatically\n        return user.to_dict()\n</code></pre>"},{"location":"http-middleware/#integration-with-interceptors","title":"Integration with Interceptors","text":"<p>The UoW context works seamlessly with all interceptors. See the Interceptors documentation for details on:</p> <ul> <li>How interceptor order affects transaction boundaries</li> <li>Implementing custom interceptors</li> <li>Transactional outbox pattern</li> <li>Message staging and flushing</li> </ul>"},{"location":"http-middleware/#complete-example","title":"Complete Example","text":"<p>Here's a complete example showing how to set up a microservice with UoW context management:</p> <pre><code>from fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\n\nfrom jararaca import (\n    AIOSQAConfig,\n    AIOSqlAlchemySessionInterceptor,\n    HttpMicroservice,\n    MessageBusPublisherInterceptor,\n    Microservice,\n    WebSocketInterceptor,\n)\nfrom jararaca.presentation.server import create_http_server\n\n\ndef fastapi_factory(lifespan):\n    \"\"\"Custom FastAPI factory with CORS.\"\"\"\n    app = FastAPI(lifespan=lifespan)\n\n    app.add_middleware(\n        CORSMiddleware,\n        allow_origins=[\"*\"],\n        allow_credentials=True,\n        allow_methods=[\"*\"],\n        allow_headers=[\"*\"],\n    )\n\n    return app\n\n# Create microservice with interceptors\napp = Microservice(\n    name=\"my-service\",\n    interceptors=[\n        # Message bus for event publishing\n        MessageBusPublisherInterceptor(...),\n\n        # Database sessions\n        AIOSqlAlchemySessionInterceptor(\n            AIOSQAConfig(\n                connection_name=\"default\",\n                url=\"postgresql+asyncpg://user:pass@localhost/mydb\",\n                inject_default=True,\n            )\n        ),\n\n        # WebSocket management\n        WebSocketInterceptor(...),\n    ],\n    controllers=[UserController, OrderController],\n)\n\n# Create HTTP server - UoW context is automatically configured\nhttp_app = HttpMicroservice(app=app, factory=fastapi_factory)\nfastapi_app = create_http_server(http_app)\n</code></pre>"},{"location":"http-middleware/#best-practices","title":"Best Practices","text":"<ol> <li>Use Context Hooks: Always access resources via <code>use_session()</code>, <code>use_publisher()</code>, etc.</li> <li>Let Interceptors Manage Transactions: Don't manually commit/rollback unless necessary</li> <li>Order Interceptors Correctly: Configuration \u2192 Message Bus \u2192 Database \u2192 WebSocket</li> <li>Handle Errors Gracefully: Let the dependency convert exceptions to HTTP responses</li> <li>Test with Mocked Context: Use fixtures to provide test contexts</li> </ol>"},{"location":"http-middleware/#advanced-manual-context-management","title":"Advanced: Manual Context Management","text":"<p>In rare cases, you might need to manually manage the UoW context (e.g., in background tasks):</p> <pre><code>from jararaca import AppTransactionContext, Container\nfrom jararaca.core.uow import UnitOfWorkContextProvider\n\nasync def background_task():\n    \"\"\"Execute a background task with UoW context.\"\"\"\n    container = Container(app)\n    uow_provider = UnitOfWorkContextProvider(app, container)\n\n    # Create transaction context manually\n    async with uow_provider(\n        AppTransactionContext(\n            controller_member_reflect=member_reflect,\n            transaction_data=transaction_data,\n        )\n    ):\n        # Your background task code\n        session = use_session()\n        # ... perform operations\n</code></pre> <p>Note: This is rarely needed as most operations should happen within request handlers where the context is automatically provided.</p>"},{"location":"http-middleware/#troubleshooting","title":"Troubleshooting","text":""},{"location":"http-middleware/#no-session-set-in-the-context","title":"\"No session set in the context\"","text":"<p>This error means you're trying to use <code>use_session()</code> outside of a UoW context. Ensure: - You're calling it from within a controller method - The <code>HttpUowContextProviderDependency</code> is properly configured - You're not trying to use it in module-level code</p>"},{"location":"http-middleware/#transactions-not-committing","title":"Transactions Not Committing","text":"<p>If changes aren't being persisted: - Check that no exceptions are being raised - Verify interceptor order is correct - Ensure you're not manually rolling back the transaction</p>"},{"location":"http-middleware/#messages-not-publishing","title":"Messages Not Publishing","text":"<p>If messages aren't being published: - Verify the database transaction succeeded - Check that the Message Bus interceptor is configured before the Database interceptor - Review logs for publishing errors</p>"},{"location":"http-middleware/#see-also","title":"See Also","text":"<ul> <li>Interceptors - Detailed information on the interceptor system</li> <li>Persistence - Database and session management</li> <li>Message Bus - Event publishing and handling</li> <li>WebSocket - WebSocket communication</li> <li>Metadata - Metadata system and custom decorators</li> </ul>"},{"location":"http-rpc/","title":"HTTP RPC Client","text":"<p>The Jararaca HTTP RPC client provides a complete REST client implementation with a decorator-based approach for defining HTTP endpoints. It includes advanced features like authentication, caching, retry logic, form data handling, and file uploads.</p>"},{"location":"http-rpc/#quick-start","title":"Quick Start","text":"<pre><code>from jararaca.rpc.http import (\n    BearerTokenAuth,\n    Body,\n    CacheMiddleware,\n    Delete,\n    File,\n    FormData,\n    Get,\n    HttpRpcClientBuilder,\n    HTTPXHttpRPCAsyncBackend,\n    Post,\n    Put,\n    Query,\n    RestClient,\n    Retry,\n    RPCRetryPolicy,\n)\n\n\n@RestClient(\"https://api.example.com\")\nclass ApiClient:\n\n    @Get(\"/users\")\n    @Query(\"limit\")\n    async def get_users(self, limit: int) -&gt; dict:\n        pass\n\n    @Post(\"/users\")\n    @Body(\"user_data\")\n    async def create_user(self, user_data: dict) -&gt; dict:\n        pass\n\n# Create client\nbackend = HTTPXHttpRPCAsyncBackend()\nauth = BearerTokenAuth(\"your-token\")\ncache = CacheMiddleware(ttl_seconds=300)\n\nbuilder = HttpRpcClientBuilder(\n    backend=backend,\n    middlewares=[auth, cache]\n)\n\nclient = builder.build(ApiClient)\n\n# Use client\nusers = await client.get_users(10)\nnew_user = await client.create_user({\"name\": \"John\", \"email\": \"john@example.com\"})\n</code></pre>"},{"location":"http-rpc/#http-method-decorators","title":"HTTP Method Decorators","text":""},{"location":"http-rpc/#basic-http-methods","title":"Basic HTTP Methods","text":"<pre><code>from jararaca.rpc.http import Delete, Get, Patch, Post, Put\n\n\n@RestClient(\"https://api.example.com\")\nclass ApiClient:\n\n    @Get(\"/users\")\n    async def get_users(self) -&gt; list[dict]:\n        pass\n\n    @Post(\"/users\")\n    async def create_user(self) -&gt; dict:\n        pass\n\n    @Put(\"/users/{user_id}\")\n    async def update_user(self) -&gt; dict:\n        pass\n\n    @Patch(\"/users/{user_id}\")\n    async def patch_user(self) -&gt; dict:\n        pass\n\n    @Delete(\"/users/{user_id}\")\n    async def delete_user(self) -&gt; bool:\n        pass\n</code></pre>"},{"location":"http-rpc/#request-parameter-decorators","title":"Request Parameter Decorators","text":""},{"location":"http-rpc/#query-parameters","title":"Query Parameters","text":"<pre><code>from jararaca.rpc.http import Query\n\n\n@Get(\"/users\")\n@Query(\"limit\")\n@Query(\"offset\")\nasync def get_users(self, limit: int, offset: int = 0) -&gt; list[dict]:\n    pass\n\n# Usage: client.get_users(10, 20) -&gt; GET /users?limit=10&amp;offset=20\n</code></pre>"},{"location":"http-rpc/#path-parameters","title":"Path Parameters","text":"<pre><code>from jararaca.rpc.http import PathParam\n\n\n@Get(\"/users/{user_id}\")\n@PathParam(\"user_id\")\nasync def get_user(self, user_id: int) -&gt; dict:\n    pass\n\n# Usage: client.get_user(123) -&gt; GET /users/123\n</code></pre>"},{"location":"http-rpc/#headers","title":"Headers","text":"<pre><code>from jararaca.rpc.http import Header\n\n\n@Get(\"/users\")\n@Header(\"X-Client-Version\")\nasync def get_users(self, x_client_version: str = \"1.0\") -&gt; list[dict]:\n    pass\n\n# Usage: client.get_users(\"2.0\") -&gt; adds X-Client-Version: 2.0 header\n</code></pre>"},{"location":"http-rpc/#request-body","title":"Request Body","text":"<pre><code>from jararaca.rpc.http import Body\n\n\n@Post(\"/users\")\n@Body(\"user_data\")\nasync def create_user(self, user_data: dict) -&gt; dict:\n    pass\n\n# Usage: client.create_user({\"name\": \"John\"}) -&gt; sends JSON body\n</code></pre>"},{"location":"http-rpc/#form-data","title":"Form Data","text":"<pre><code>from jararaca.rpc.http import FormData\n\n\n@Post(\"/login\")\n@FormData(\"username\")\n@FormData(\"password\")\nasync def login(self, username: str, password: str) -&gt; dict:\n    pass\n\n# Usage: client.login(\"user\", \"pass\") -&gt; sends form-encoded data\n</code></pre>"},{"location":"http-rpc/#file-uploads","title":"File Uploads","text":"<pre><code>from jararaca.rpc.http import File, FormData\n\n\n@Post(\"/upload\")\n@FormData(\"name\")\n@File(\"avatar\")\nasync def upload_avatar(self, name: str, avatar: bytes) -&gt; dict:\n    pass\n\n# Usage:\n# with open(\"avatar.jpg\", \"rb\") as f:\n#     result = await client.upload_avatar(\"John\", f.read())\n</code></pre>"},{"location":"http-rpc/#configuration-decorators","title":"Configuration Decorators","text":""},{"location":"http-rpc/#timeout","title":"Timeout","text":"<pre><code>from jararaca.rpc.http import Timeout\n\n\n@Get(\"/slow-endpoint\")\n@Timeout(30.0)  # 30 seconds timeout\nasync def slow_request(self) -&gt; dict:\n    pass\n</code></pre>"},{"location":"http-rpc/#retry-configuration","title":"Retry Configuration","text":"<pre><code>from jararaca.rpc.http import Retry, RPCRetryPolicy\n\n\n@Get(\"/unreliable-endpoint\")\n@Retry(RPCRetryPolicy(\n    max_attempts=3,\n    backoff_factor=2.0,\n    retry_on_status_codes=[500, 502, 503, 504]\n))\nasync def unreliable_request(self) -&gt; dict:\n    pass\n</code></pre>"},{"location":"http-rpc/#content-type","title":"Content Type","text":"<pre><code>from jararaca.rpc.http import ContentType\n\n\n@Post(\"/xml-endpoint\")\n@ContentType(\"application/xml\")\n@Body(\"xml_data\")\nasync def send_xml(self, xml_data: str) -&gt; dict:\n    pass\n</code></pre>"},{"location":"http-rpc/#authentication","title":"Authentication","text":""},{"location":"http-rpc/#bearer-token-authentication","title":"Bearer Token Authentication","text":"<pre><code>from jararaca.rpc.http import BearerTokenAuth\n\nauth = BearerTokenAuth(\"your-access-token\")\nbuilder = HttpRpcClientBuilder(backend=backend, middlewares=[auth])\n</code></pre>"},{"location":"http-rpc/#basic-authentication","title":"Basic Authentication","text":"<pre><code>from jararaca.rpc.http import BasicAuth\n\nauth = BasicAuth(\"username\", \"password\")\nbuilder = HttpRpcClientBuilder(backend=backend, middlewares=[auth])\n</code></pre>"},{"location":"http-rpc/#api-key-authentication","title":"API Key Authentication","text":"<pre><code>from jararaca.rpc.http import ApiKeyAuth\n\nauth = ApiKeyAuth(\"your-api-key\", header_name=\"X-API-Key\")\nbuilder = HttpRpcClientBuilder(backend=backend, middlewares=[auth])\n</code></pre>"},{"location":"http-rpc/#middleware","title":"Middleware","text":""},{"location":"http-rpc/#cache-middleware","title":"Cache Middleware","text":"<p>The cache middleware provides in-memory caching for GET requests:</p> <pre><code>from jararaca.rpc.http import CacheMiddleware\n\ncache = CacheMiddleware(ttl_seconds=300)  # Cache for 5 minutes\nbuilder = HttpRpcClientBuilder(backend=backend, middlewares=[cache])\n</code></pre>"},{"location":"http-rpc/#custom-request-middleware","title":"Custom Request Middleware","text":"<pre><code>from jararaca.rpc.http import HttpRPCRequest, RequestMiddleware\n\n\nclass LoggingMiddleware(RequestMiddleware):\n    def on_request(self, request: HttpRPCRequest) -&gt; HttpRPCRequest:\n        print(f\"Making request to {request.url}\")\n        return request\n\nlogging_middleware = LoggingMiddleware()\nbuilder = HttpRpcClientBuilder(backend=backend, middlewares=[logging_middleware])\n</code></pre>"},{"location":"http-rpc/#response-middleware","title":"Response Middleware","text":"<pre><code>from jararaca.rpc.http import HttpRPCRequest, HttpRPCResponse, ResponseMiddleware\n\n\nclass ResponseLoggingMiddleware(ResponseMiddleware):\n    def on_response(self, request: HttpRPCRequest, response: HttpRPCResponse) -&gt; HttpRPCResponse:\n        print(f\"Response from {request.url}: {response.status_code}\")\n        return response\n\nresponse_middleware = ResponseLoggingMiddleware()\nbuilder = HttpRpcClientBuilder(\n    backend=backend,\n    response_middlewares=[response_middleware]\n)\n</code></pre>"},{"location":"http-rpc/#hooks","title":"Hooks","text":""},{"location":"http-rpc/#request-hooks","title":"Request Hooks","text":"<pre><code>from jararaca.rpc.http import HttpRPCRequest, RequestHook\n\n\nclass RequestTimingHook(RequestHook):\n    def before_request(self, request: HttpRPCRequest) -&gt; HttpRPCRequest:\n        request.start_time = time.time()\n        return request\n\ntiming_hook = RequestTimingHook()\nbuilder = HttpRpcClientBuilder(\n    backend=backend,\n    request_hooks=[timing_hook]\n)\n</code></pre>"},{"location":"http-rpc/#response-hooks","title":"Response Hooks","text":"<pre><code>from jararaca.rpc.http import HttpRPCRequest, HttpRPCResponse, ResponseHook\n\n\nclass ResponseTimingHook(ResponseHook):\n    def after_response(self, request: HttpRPCRequest, response: HttpRPCResponse) -&gt; HttpRPCResponse:\n        if hasattr(request, 'start_time'):\n            elapsed = time.time() - request.start_time\n            print(f\"Request took {elapsed:.2f} seconds\")\n        return response\n\ntiming_hook = ResponseTimingHook()\nbuilder = HttpRpcClientBuilder(\n    backend=backend,\n    response_hooks=[timing_hook]\n)\n</code></pre>"},{"location":"http-rpc/#error-handling","title":"Error Handling","text":""},{"location":"http-rpc/#global-error-handlers","title":"Global Error Handlers","text":"<pre><code>from jararaca.rpc.http import GlobalHttpErrorHandler\n\n\n@GlobalHttpErrorHandler(404)\ndef handle_not_found(request, response):\n    return {\"error\": \"Resource not found\"}\n\n@GlobalHttpErrorHandler(500)\ndef handle_server_error(request, response):\n    return {\"error\": \"Server error occurred\"}\n</code></pre>"},{"location":"http-rpc/#route-specific-error-handlers","title":"Route-Specific Error Handlers","text":"<pre><code>from jararaca.rpc.http import RouteHttpErrorHandler\n\n\n@Get(\"/users/{user_id}\")\n@PathParam(\"user_id\")\n@RouteHttpErrorHandler(404)\ndef handle_user_not_found(request, response):\n    return {\"error\": f\"User not found\"}\nasync def get_user(self, user_id: int) -&gt; dict:\n    pass\n</code></pre>"},{"location":"http-rpc/#advanced-features","title":"Advanced Features","text":""},{"location":"http-rpc/#complete-example-with-all-features","title":"Complete Example with All Features","text":"<pre><code>import asyncio\n\nfrom jararaca.rpc.http import (\n    ApiKeyAuth,\n    BasicAuth,\n    BearerTokenAuth,\n    Body,\n    CacheMiddleware,\n    ContentType,\n    Delete,\n    File,\n    FormData,\n    Get,\n    GlobalHttpErrorHandler,\n    Header,\n    HttpRpcClientBuilder,\n    HTTPXHttpRPCAsyncBackend,\n    PathParam,\n    Post,\n    Put,\n    Query,\n    RequestHook,\n    ResponseHook,\n    ResponseMiddleware,\n    RestClient,\n    Retry,\n    RouteHttpErrorHandler,\n    RPCRetryPolicy,\n    Timeout,\n)\n\n\n# Custom middleware\nclass RequestIdMiddleware(RequestMiddleware):\n    def on_request(self, request: HttpRPCRequest) -&gt; HttpRPCRequest:\n        import uuid\n        request.headers.append((\"X-Request-ID\", str(uuid.uuid4())))\n        return request\n\n# Error handlers\n@GlobalHttpErrorHandler(500)\ndef handle_server_error(request, response):\n    return {\"error\": \"Server error\", \"status\": 500}\n\n@RestClient(\"https://api.example.com/v1\")\nclass AdvancedApiClient:\n\n    @Get(\"/users\")\n    @Query(\"limit\")\n    @Query(\"search\")\n    @Header(\"X-Client-Version\")\n    @Timeout(10.0)\n    @CacheMiddleware(ttl_seconds=60)\n    async def search_users(\n        self,\n        limit: int = 10,\n        search: str = \"\",\n        x_client_version: str = \"1.0\"\n    ) -&gt; list[dict]:\n        pass\n\n    @Post(\"/users\")\n    @Body(\"user_data\")\n    @ContentType(\"application/json\")\n    @Retry(RPCRetryPolicy(max_attempts=3, backoff_factor=1.5))\n    @RouteHttpErrorHandler(400)\n    def handle_validation_error(request, response):\n        return {\"error\": \"Validation failed\", \"details\": response.data}\n    async def create_user(self, user_data: dict) -&gt; dict:\n        pass\n\n    @Put(\"/users/{user_id}/avatar\")\n    @PathParam(\"user_id\")\n    @File(\"avatar\")\n    @FormData(\"description\")\n    @Timeout(30.0)\n    async def upload_user_avatar(\n        self,\n        user_id: int,\n        avatar: bytes,\n        description: str = \"\"\n    ) -&gt; dict:\n        pass\n\n    @Delete(\"/users/{user_id}\")\n    @PathParam(\"user_id\")\n    @Retry(RPCRetryPolicy(max_attempts=2))\n    async def delete_user(self, user_id: int) -&gt; bool:\n        pass\n\nasync def main():\n    # Setup backend and middleware\n    backend = HTTPXHttpRPCAsyncBackend(default_timeout=15.0)\n    auth = BearerTokenAuth(\"your-access-token\")\n    cache = CacheMiddleware(ttl_seconds=300)\n    request_id = RequestIdMiddleware()\n\n    # Build client with all features\n    builder = HttpRpcClientBuilder(\n        backend=backend,\n        middlewares=[auth, cache, request_id],\n        response_middlewares=[],\n        request_hooks=[],\n        response_hooks=[]\n    )\n\n    client = builder.build(AdvancedApiClient)\n\n    try:\n        # Use the client\n        users = await client.search_users(limit=20, search=\"john\")\n        new_user = await client.create_user({\n            \"name\": \"Jane Doe\",\n            \"email\": \"jane@example.com\"\n        })\n\n        # Upload avatar\n        with open(\"avatar.jpg\", \"rb\") as f:\n            avatar_result = await client.upload_user_avatar(\n                user_id=new_user[\"id\"],\n                avatar=f.read(),\n                description=\"Profile picture\"\n            )\n\n        print(\"\u2705 All operations completed successfully\")\n\n    except Exception as e:\n        print(f\"\u274c Error: {e}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"http-rpc/#backend-configuration","title":"Backend Configuration","text":""},{"location":"http-rpc/#httpx-backend-options","title":"HTTPX Backend Options","text":"<pre><code>from jararaca.rpc.http import HTTPXHttpRPCAsyncBackend\n\nbackend = HTTPXHttpRPCAsyncBackend(\n    prefix_url=\"https://api.example.com\",  # Base URL for all requests\n    default_timeout=30.0  # Default timeout in seconds\n)\n</code></pre>"},{"location":"http-rpc/#exception-handling","title":"Exception Handling","text":"<p>The HTTP RPC client provides several exception types:</p> <ul> <li><code>TimeoutException</code>: Raised when a request times out</li> <li><code>RPCRequestNetworkError</code>: Raised for network-related errors</li> <li><code>RPCUnhandleError</code>: Raised when no error handler matches the response status</li> </ul> <pre><code>from jararaca.rpc.http import RPCRequestNetworkError, RPCUnhandleError, TimeoutException\n\ntry:\n    result = await client.get_users()\nexcept TimeoutException:\n    print(\"Request timed out\")\nexcept RPCRequestNetworkError:\n    print(\"Network error occurred\")\nexcept RPCUnhandleError as e:\n    print(f\"Unhandled error: {e.response.status_code}\")\n</code></pre>"},{"location":"http-rpc/#best-practices","title":"Best Practices","text":"<ol> <li>Use Type Hints: Always provide type hints for better IDE support and documentation</li> <li>Error Handling: Implement appropriate error handlers for expected error conditions</li> <li>Timeouts: Set reasonable timeouts for all requests</li> <li>Retry Logic: Use retry configuration for operations that may fail temporarily</li> <li>Caching: Use cache middleware for read-heavy operations</li> <li>Authentication: Store tokens securely and refresh them as needed</li> <li>Middleware Order: Consider the order of middleware execution</li> <li>Resource Management: Use async context managers when appropriate</li> </ol>"},{"location":"http-rpc/#migration-from-previous-versions","title":"Migration from Previous Versions","text":"<p>If you're upgrading from a previous version of the HTTP RPC client, here are the key changes:</p> <ol> <li>New Decorators: <code>@FormData</code>, <code>@File</code>, <code>@Timeout</code>, <code>@Retry</code>, <code>@ContentType</code></li> <li>Authentication: New authentication middleware classes</li> <li>Caching: Built-in cache middleware</li> <li>Enhanced Error Handling: More granular exception types</li> <li>Middleware System: Expanded middleware and hooks system</li> <li>Form Data Support: Native support for form submissions and file uploads</li> </ol> <p>All existing functionality remains backward compatible.</p>"},{"location":"interceptors/","title":"Interceptors in Jararaca","text":"<p>Interceptors are a powerful mechanism in Jararaca for implementing cross-cutting concerns across different execution contexts. They allow you to wrap the execution of HTTP requests, message handling, scheduled tasks, and WebSocket communications with common behaviors such as transaction management, message publishing, and WebSocket message dispatching.</p>"},{"location":"interceptors/#overview-of-the-interceptor-system","title":"Overview of the Interceptor System","text":"<p>Interceptors in Jararaca work by wrapping the execution of handlers in different contexts:</p> <ul> <li>HTTP Controllers: Intercept incoming HTTP requests before they reach controllers</li> <li>Message Bus Consumers: Intercept message processing in workers</li> <li>Scheduled Tasks: Intercept scheduled task execution</li> <li>WebSocket Connections: Manage WebSocket connections and message dispatching</li> </ul> <p>Each interceptor provides a specific capability to the application through context variables, allowing your code to access these capabilities through hook functions like <code>use_session()</code>, <code>use_publisher()</code>, and <code>use_ws_manager()</code>.</p>"},{"location":"interceptors/#the-atomic-layer-transactions-messages-and-websockets","title":"The Atomic Layer: Transactions, Messages, and WebSockets","text":"<p>The true power of the interceptor system lies in how it creates an atomic layer that ensures consistency across database operations, message publishing, and WebSocket communications. This is particularly important for implementing transactional outbox patterns and ensuring consistency in distributed systems.</p> <pre><code>sequenceDiagram\n    participant Client\n    participant HTTP Context\n    participant DB Interceptor\n    participant MessageBus Interceptor\n    participant WebSocket Interceptor\n    participant Database\n    participant MessageBroker\n    participant WebSocketBackend\n\n    Client-&gt;&gt;HTTP Context: HTTP Request\n    Note over HTTP Context,WebSocketBackend: Transaction Boundary Begins\n\n    HTTP Context-&gt;&gt;DB Interceptor: Begin Transaction\n    DB Interceptor-&gt;&gt;Database: Begin DB Transaction\n\n    HTTP Context-&gt;&gt;MessageBus Interceptor: Stage Messages\n    MessageBus Interceptor-&gt;&gt;MessageBus Interceptor: Queue Messages\n\n    HTTP Context-&gt;&gt;WebSocket Interceptor: Stage WebSocket Messages\n    WebSocket Interceptor-&gt;&gt;WebSocket Interceptor: Queue WebSocket Messages\n\n    HTTP Context-&gt;&gt;DB Interceptor: Commit Transaction\n    DB Interceptor-&gt;&gt;Database: Commit DB Transaction\n    Database--&gt;&gt;DB Interceptor: Success\n\n    DB Interceptor--&gt;&gt;MessageBus Interceptor: DB Commit Success\n    MessageBus Interceptor-&gt;&gt;MessageBroker: Flush Queued Messages\n\n    MessageBus Interceptor--&gt;&gt;WebSocket Interceptor: Messages Published\n    WebSocket Interceptor-&gt;&gt;WebSocketBackend: Flush WebSocket Messages\n\n    Note over HTTP Context,WebSocketBackend: Transaction Boundary Ends\n\n    HTTP Context--&gt;&gt;Client: HTTP Response\n</code></pre>"},{"location":"interceptors/#order-of-interceptors-matters","title":"Order of Interceptors Matters","text":"<p>The order in which interceptors are configured in your application is critical. The typical order is:</p> <ol> <li>Configuration Interceptor - Loads and provides application configuration</li> <li>Message Bus Publisher Interceptor - Provides message publishing capabilities</li> <li>Database Session Interceptor - Provides database transaction capabilities</li> <li>WebSocket Interceptor - Provides WebSocket communication capabilities</li> </ol> <p>This order ensures that:</p> <ol> <li>The database transaction is committed first</li> <li>Only after successful database commit, messages are published to the message broker</li> <li>Finally, WebSocket messages are dispatched to connected clients</li> </ol>"},{"location":"interceptors/#implementing-transactional-outbox-pattern","title":"Implementing Transactional Outbox Pattern","text":"<p>Jararaca's interceptor system makes implementing the transactional outbox pattern straightforward. This pattern ensures that database changes and message publishing are atomic:</p> <pre><code>from jararaca import use_publisher, use_session\n\nasync def create_user(user_data: dict):\n    # Get the current database session from the context\n    session = use_session()\n\n    # Get the message publisher from the context\n    publisher = use_publisher()\n\n    # Create user in database\n    new_user = User(**user_data)\n    session.add(new_user)\n\n    # Stage a message to be published after successful transaction\n    await publisher.publish(\"user_created\", UserCreatedEvent(id=new_user.id))\n\n    # The actual database commit and message publishing\n    # happens automatically when the request handling is complete,\n    # managed by the interceptors\n</code></pre> <p>When this code executes: 1. The database session interceptor ensures the user is committed to the database 2. If the database transaction succeeds, the message bus interceptor publishes the staged message 3. If the database transaction fails, no messages are published</p>"},{"location":"interceptors/#contexts-and-interceptors","title":"Contexts and Interceptors","text":"<p>Jararaca supports different execution contexts, and interceptors behave differently in each:</p>"},{"location":"interceptors/#http-context","title":"HTTP Context","text":"<p>In an HTTP context, all interceptors are active: - Database Session Interceptor manages transactions - Message Bus Publisher Interceptor stages and flushes messages - WebSocket Interceptor stages and flushes WebSocket messages</p>"},{"location":"interceptors/#worker-context","title":"Worker Context","text":"<p>In a message bus worker context: - Database Session Interceptor manages transactions - Message Bus Publisher Interceptor stages and flushes messages - WebSocket Interceptor stages and flushes WebSocket messages</p>"},{"location":"interceptors/#scheduler-context","title":"Scheduler Context","text":"<p>In a scheduler context: - Database Session Interceptor manages transactions - Message Bus Publisher Interceptor stages and flushes messages - WebSocket Interceptor stages and flushes WebSocket messages</p>"},{"location":"interceptors/#websocket-context","title":"WebSocket Context","text":"<p>In a WebSocket context: - Database Session Interceptor manages transactions - Message Bus Publisher is usually not active (as defined in the <code>intercept</code> method) - WebSocket communications are managed directly</p>"},{"location":"interceptors/#code-example-configuring-interceptors","title":"Code Example: Configuring Interceptors","text":"<pre><code>from jararaca import (\n    AIOSQAConfig,\n    AIOSqlAlchemySessionInterceptor,\n    MessageBusPublisherInterceptor,\n    Microservice,\n    WebSocketInterceptor,\n)\n\n# Create the microservice\nmicroservice = Microservice(\n    name=\"my-service\",\n    interceptors=[\n        # Configuration interceptor (if any)\n        # ...\n\n        # Message bus interceptor\n        lambda config: MessageBusPublisherInterceptor(\n            connection_factory=message_publisher_factory,\n            connection_name=\"default\",\n            message_scheduler=message_scheduler,\n        ),\n\n        # Database session interceptor\n        lambda config: AIOSqlAlchemySessionInterceptor(\n            AIOSQAConfig(\n                url=\"postgresql+asyncpg://user:password@localhost/dbname\",\n                connection_name=\"default\",\n                inject_default=True,\n            )\n        ),\n\n        # WebSocket interceptor\n        lambda config: WebSocketInterceptor(\n            backend=redis_websocket_backend,\n        ),\n    ],\n    # Other microservice configuration...\n)\n</code></pre>"},{"location":"interceptors/#best-practices","title":"Best Practices","text":"<ol> <li>Order Matters: Always configure interceptors in the order: configuration \u2192 message bus \u2192 database \u2192 WebSocket</li> <li>Transaction Boundaries: Be aware that interceptors create implicit transaction boundaries</li> <li>Error Handling: Database errors will prevent message publishing and WebSocket dispatching</li> <li>Idempotency: Design your message handlers to be idempotent in case of retries</li> <li>Context Variables: Use the appropriate context hooks (<code>use_session()</code>, <code>use_publisher()</code>, etc.) to access the capabilities provided by interceptors</li> </ol>"},{"location":"interceptors/#advanced-usage-custom-interceptors","title":"Advanced Usage: Custom Interceptors","text":"<p>You can create custom interceptors by implementing the <code>AppInterceptor</code> interface:</p> <pre><code>from contextlib import asynccontextmanager\nfrom typing import AsyncGenerator\nfrom jararaca import AppInterceptor, AppTransactionContext\n\nclass CustomInterceptor(AppInterceptor):\n    @asynccontextmanager\n    async def intercept(self, app_context: AppTransactionContext) -&gt; AsyncGenerator[None, None]:\n        # Pre-processing logic\n\n        try:\n            # Let the request handler execute\n            yield\n            # Post-processing after successful execution\n        except Exception as e:\n            # Handle exceptions\n            raise e\n</code></pre>"},{"location":"interceptors/#conclusion","title":"Conclusion","text":"<p>Jararaca's interceptor system provides a powerful way to implement cross-cutting concerns and ensure consistency across database operations, message publishing, and WebSocket communications. By properly configuring interceptors, you can implement patterns like the transactional outbox pattern with minimal effort, ensuring that your distributed system maintains consistency even in the face of failures.</p>"},{"location":"messagebus/","title":"Jararaca Message Bus Architecture","text":"<p>The message bus system in Jararaca provides a robust infrastructure for asynchronous message processing using a publisher-consumer pattern. This document explains how the message bus works, from message definition to processing flows.</p>"},{"location":"messagebus/#overview","title":"Overview","text":"<p>The message bus system consists of several key components that work together to provide a seamless experience for defining, publishing, and consuming messages.</p> <pre><code>graph TB\n    subgraph \"Message Definition\"\n        Message[Message]\n        MessageOf[MessageOf]\n    end\n\n    subgraph \"Message Handling\"\n        MessageHandler[MessageHandler]\n        MessageBusController[MessageBusController]\n        BusMessageController[BusMessageController]\n    end\n\n    subgraph \"Worker Infrastructure\"\n        MessageBusWorker[MessageBusWorker]\n        AioPikaMicroserviceConsumer[AioPikaMicroserviceConsumer]\n        MessageHandlerCallback[MessageHandlerCallback]\n    end\n\n    subgraph \"Utilities\"\n        ack[ack]\n        nack[nack]\n        retry[retry]\n        retry_later[retry_later]\n        reject[reject]\n    end\n\n    Message --&gt; MessageOf\n    MessageHandler --&gt; MessageBusController\n    MessageBusController --&gt; MessageBusWorker\n    MessageBusWorker --&gt; AioPikaMicroserviceConsumer\n    AioPikaMicroserviceConsumer --&gt; MessageHandlerCallback\n    MessageHandlerCallback --&gt; BusMessageController\n    BusMessageController --&gt; ack\n    BusMessageController --&gt; nack\n    BusMessageController --&gt; reject\n    BusMessageController --&gt; retry\n    BusMessageController --&gt; retry_later\n</code></pre>"},{"location":"messagebus/#message-structure","title":"Message Structure","text":"<p>Messages in Jararaca are built on Pydantic models, which provide type validation and serialization capabilities.</p>"},{"location":"messagebus/#message-types-tasks-vs-events","title":"Message Types: Tasks vs Events","text":"<p>Jararaca supports two fundamental message types:</p> <ul> <li> <p>Tasks: Designed to be handled exactly once by a single MessageHandler. It is not recommended to have multiple MessageHandlers listening to the same Task type. Tasks represent commands or operations that should be executed once.</p> </li> <li> <p>Events: Can be listened to by multiple parts of the application. Events are ideal for scenarios where different components need to react to the same occurrence, providing looser coupling throughout the codebase.</p> </li> </ul> <pre><code>graph LR\n    Task[Task Message] --&gt; Handler1[Single Handler]\n    Event[Event Message] --&gt; HandlerA[Handler A]\n    Event --&gt; HandlerB[Handler B]\n    Event --&gt; HandlerC[Handler C]\n</code></pre> <p>When designing your message architecture, consider:</p> <ul> <li>Use Tasks when an operation should be performed exactly once</li> <li>Use Events when multiple systems need to react to the same occurrence</li> <li>Events promote better decoupling between components</li> </ul>"},{"location":"messagebus/#base-message-class","title":"Base Message Class","text":"<pre><code>classDiagram\n    class Message {\n        +MESSAGE_TOPIC: ClassVar[str]\n        +MESSAGE_TYPE: ClassVar[Literal[\"task\", \"event\"]]\n        +publish() async\n    }\n    class BaseModel {\n        +model_validate_json()\n        +json()\n    }\n    class UserCreatedMessage {\n        +MESSAGE_TOPIC: \"user.created\"\n        +MESSAGE_TYPE: \"event\"\n        +user_id: str\n        +username: str\n        +email: str\n    }\n    BaseModel &lt;|-- Message\n    Message &lt;|-- UserCreatedMessage\n</code></pre>"},{"location":"messagebus/#example-message-definition","title":"Example Message Definition","text":"<pre><code>from jararaca import Message\n\n\nclass UserCreatedMessage(Message):\n    MESSAGE_TOPIC = \"user.created\"\n    MESSAGE_TYPE = \"event\"  # or \"task\"\n\n    user_id: str\n    username: str\n    email: str\n</code></pre>"},{"location":"messagebus/#message-processing-flow","title":"Message Processing Flow","text":"<p>When a message is published, it goes through several processing stages before being handled by the appropriate consumer.</p> <pre><code>sequenceDiagram\n    participant P as Publisher\n    participant E as Exchange (RabbitMQ)\n    participant Q as Queue\n    participant W as MessageBusWorker\n    participant C as Consumer (Handler)\n\n    P-&gt;&gt;E: publish(message, topic)\n    E-&gt;&gt;Q: route message by topic\n    W-&gt;&gt;Q: consume messages\n    Q-&gt;&gt;W: deliver message\n    W-&gt;&gt;C: invoke message handler\n    C-&gt;&gt;W: process &amp; acknowledge\n</code></pre>"},{"location":"messagebus/#message-routing-exchanges-and-queues","title":"Message Routing: Exchanges and Queues","text":"<p>Jararaca's message bus system leverages RabbitMQ's exchange and queue architecture to efficiently route messages between publishers and consumers.</p>"},{"location":"messagebus/#exchange-and-queue-structure-example","title":"Exchange and Queue Structure Example","text":"<p>The following diagram illustrates how the exchange and queue system works in a typical Jararaca application:</p> <pre><code>graph LR\n    subgraph Publishers\n        P1[UserService]\n        P2[OrderService]\n        P3[NotificationService]\n    end\n\n    subgraph \"Exchange (jararaca_ex)\"\n        E[Topic Exchange]\n    end\n\n    subgraph Queues\n        Q1[user_service_queue]\n        Q2[order_service_queue]\n        Q3[notification_service_queue]\n        Q4[analytics_service_queue]\n    end\n\n    subgraph Consumers\n        C1[UserServiceHandler]\n        C2[OrderServiceHandler]\n        C3[NotificationServiceHandler]\n        C4[AnalyticsServiceHandler]\n    end\n\n    P1 --&gt;|user.created| E\n    P1 --&gt;|user.updated| E\n    P2 --&gt;|order.created| E\n    P2 --&gt;|order.updated| E\n    P3 --&gt;|notification.sent| E\n\n    E --&gt;|user.created| Q1\n    E --&gt;|user.updated| Q1\n    E --&gt;|order.created| Q2\n    E --&gt;|order.updated| Q2\n    E --&gt;|notification.sent| Q3\n\n    %% Events can be routed to multiple queues\n    E --&gt;|user.created| Q4\n    E --&gt;|order.created| Q4\n\n    Q1 --&gt; C1\n    Q2 --&gt; C2\n    Q3 --&gt; C3\n    Q4 --&gt; C4\n\n    style E fill:#f96,stroke:#333,stroke-width:2px\n    style Q1 fill:#9cf,stroke:#333,stroke-width:1px\n    style Q2 fill:#9cf,stroke:#333,stroke-width:1px\n    style Q3 fill:#9cf,stroke:#333,stroke-width:1px\n    style Q4 fill:#9cf,stroke:#333,stroke-width:1px\n</code></pre>"},{"location":"messagebus/#how-message-routing-works","title":"How Message Routing Works","text":"<ol> <li>Publishers send messages to the exchange with a specific topic (e.g., <code>user.created</code>, <code>order.updated</code>).</li> <li>The Exchange routes these messages to queues based on binding patterns.</li> <li>Queues hold messages until they are consumed.</li> <li>Consumers process messages from their assigned queues.</li> </ol>"},{"location":"messagebus/#key-concepts","title":"Key Concepts:","text":"<ul> <li>Topic-based routing: Messages are routed based on their topic (e.g., <code>user.created</code>)</li> <li>Multiple bindings: A single exchange can route to multiple queues (especially useful for event messages)</li> <li>Service isolation: Each service typically has its own queue</li> <li>Message persistence: Messages remain in queues until processed, even if consumers are temporarily unavailable</li> </ul>"},{"location":"messagebus/#example-queue-binding-configuration","title":"Example Queue Binding Configuration","text":"<pre><code>from jararaca import MessageBusController, MessageHandler\n\n# AioPikaWorkerConfig is not exported by jararaca, so we import it from the module\nfrom jararaca.messagebus.worker import AioPikaWorkerConfig\n\n# Define worker configuration with queue binding patterns\nworker_config = AioPikaWorkerConfig(\n    url=\"amqp://guest:guest@localhost/\",\n    exchange=\"jararaca_ex\",\n    queue=\"user_service_queue\",\n    binding_keys=[\"user.*\", \"notification.user.*\"]  # This queue receives all user-related topics\n)\n</code></pre> <p>This message routing architecture allows for flexible and scalable communication patterns between different parts of your application, supporting both direct task assignment and broad event publishing.</p>"},{"location":"messagebus/#worker-infrastructure","title":"Worker Infrastructure","text":"<p>The MessageBusWorker is the central piece that orchestrates message consumption and processing.</p> <pre><code>classDiagram\n    class MessageBusWorker {\n        -app: Microservice\n        -config: AioPikaWorkerConfig\n        -container: Container\n        -lifecycle: AppLifecycle\n        -uow_context_provider: UnitOfWorkContextProvider\n        -_consumer: AioPikaMicroserviceConsumer\n        +start_async()\n        +start_sync()\n    }\n\n    class AioPikaMicroserviceConsumer {\n        -config: AioPikaWorkerConfig\n        -message_handler_set: Set[MessageHandlerData]\n        -incoming_map: Dict[str, MessageHandlerData]\n        -uow_context_provider: UnitOfWorkContextProvider\n        -shutdown_event: Event\n        -lock: Lock\n        -tasks: Set[Task]\n        +consume()\n        +wait_all_tasks_done()\n    }\n\n    class MessageHandlerCallback {\n        -consumer: AioPikaMicroserviceConsumer\n        -queue_name: str\n        -routing_key: str\n        -message_handler: MessageHandlerData\n        +message_consumer()\n        +handle_message_consume_done()\n        +handle_reject_message()\n        +handle_message()\n    }\n\n    MessageBusWorker --&gt; AioPikaMicroserviceConsumer\n    AioPikaMicroserviceConsumer --&gt; MessageHandlerCallback\n</code></pre>"},{"location":"messagebus/#worker-initialization-process","title":"Worker Initialization Process","text":"<pre><code>flowchart TD\n    A[MessageBusWorker Initialization] --&gt; B[Load App Controllers]\n    B --&gt; C[Find MessageBusControllers]\n    C --&gt; D[Extract Message Handlers]\n    D --&gt; E[Create AioPikaMicroserviceConsumer]\n    E --&gt; F[Connect to RabbitMQ]\n    F --&gt; G[Declare Exchanges &amp; Queues]\n    G --&gt; H[Bind Queues to Topics]\n    H --&gt; I[Start Consuming Messages]\n</code></pre>"},{"location":"messagebus/#message-consumption-process","title":"Message Consumption Process","text":"<pre><code>flowchart TD\n    A[Message Received] --&gt; B[Create Task for Message]\n    B --&gt; C[Extract Message Type]\n    C --&gt; D[Deserialize Message]\n    D --&gt; E[Create MessageBusAppContext]\n    E --&gt; F[Setup BusMessageController]\n    F --&gt; G[Invoke Handler Function]\n    G --&gt;|Success| H[Acknowledge Message]\n    G --&gt;|Failure| I[Handle Exception]\n    I --&gt;|Retry| J[Requeue Message]\n    I --&gt;|Discard| K[Reject Message]\n</code></pre>"},{"location":"messagebus/#handler-registration","title":"Handler Registration","text":"<p>Jararaca uses a declarative approach to register message handlers through decorators.</p> <pre><code>classDiagram\n    class MessageBusController {\n        -messagebus_factory: Callable\n        +get_messagebus_factory()\n        +register()\n        +get_messagebus()\n    }\n\n    class MessageHandler {\n        -message_type: Type[Message]\n        -timeout: Optional[int]\n        -exception_handler: Optional[Callable]\n        -requeue_on_exception: bool\n        -auto_ack: bool\n        +register()\n        +get_message_incoming()\n    }\n\n    class MessageHandlerData {\n        +message_type: Type[Message]\n        +spec: MessageHandler\n        +callable: Callable\n    }\n\n    MessageBusController --&gt; MessageHandler\n    MessageHandler --&gt; MessageHandlerData\n</code></pre>"},{"location":"messagebus/#example-handler-definition","title":"Example Handler Definition","text":"<pre><code>from jararaca import Message, MessageBusController, MessageHandler, MessageOf\n\n\n@MessageBusController()\nclass UserEventsController:\n    @MessageHandler(UserCreatedMessage, timeout=30, nack_on_exception=True)\n    async def handle_user_created(self, message: MessageOf[UserCreatedMessage]):\n        user_data = message.payload()\n        # Process the message\n        print(f\"User created: {user_data.username}\")\n</code></pre>"},{"location":"messagebus/#message-control-flow","title":"Message Control Flow","text":"<p>During message processing, handlers can control the message acknowledgment flow.</p> <pre><code>sequenceDiagram\n    participant H as Handler\n    participant C as BusMessageController\n    participant Q as Queue\n\n    H-&gt;&gt;C: ack()\n    C-&gt;&gt;Q: Acknowledge Message\n\n    H-&gt;&gt;C: nack()\n    C-&gt;&gt;Q: Negative Acknowledge\n\n    H-&gt;&gt;C: reject()\n    C-&gt;&gt;Q: Reject Message\n\n    H-&gt;&gt;C: retry()\n    C-&gt;&gt;Q: Requeue Message\n</code></pre>"},{"location":"messagebus/#message-control-utilities","title":"Message Control Utilities","text":"<pre><code>from jararaca import ack, nack, reject, retry\n\n\n@MessageBusController()\nclass TaskProcessor:\n    @MessageHandler(TaskMessage, auto_ack=False)\n    async def process_task(self, message: MessageOf[TaskMessage]):\n        try:\n            task_data = message.payload()\n            # Process the task\n            await self.process_task_data(task_data)\n            # Manually acknowledge successful processing\n            await ack()\n        except TemporaryError:\n            # Request message retry\n            await retry()\n        except PermanentError:\n            # Reject the message\n            await reject()\n</code></pre>"},{"location":"messagebus/#error-handling","title":"Error Handling","text":"<p>The message bus provides comprehensive error handling mechanisms:</p> <pre><code>flowchart TD\n    A[Message Processing] --&gt;|Success| B[Acknowledge]\n    A --&gt;|Failure| C[Exception Handling]\n    C --&gt;|Has Exception Handler| D[Custom Handler]\n    C --&gt;|No Exception Handler| E[Default Logging]\n    D --&gt;|Requeue Configured| F[Retry Message]\n    D --&gt;|Discard Configured| G[Reject Message]\n    E --&gt;|Requeue Configured| F\n    E --&gt;|Discard Configured| G\n</code></pre>"},{"location":"messagebus/#integration-with-other-jararaca-components","title":"Integration with Other Jararaca Components","text":"<p>The message bus system integrates with other Jararaca components for a unified experience:</p> <pre><code>flowchart LR\n    A[Message Bus] &lt;--&gt; B[Database Sessions]\n    A &lt;--&gt; C[WebSockets]\n    A &lt;--&gt; D[Scheduler]\n    A &lt;--&gt; E[HTTP API]\n\n    B &lt;-- use_session --&gt; F[Shared Context]\n    C &lt;-- use_ws_manager --&gt; F\n    A &lt;-- use_publisher --&gt; F\n</code></pre>"},{"location":"messagebus/#websocket-integration-example","title":"WebSocket Integration Example","text":"<pre><code>@MessageBusController()\nclass NotificationController:\n    @MessageHandler(UserActivityMessage)\n    async def handle_user_activity(self, message: MessageOf[UserActivityMessage]):\n        user_data = message.payload()\n\n        # Create a WebSocket message\n        notification = ActivityNotification(\n            user_id=user_data.user_id,\n            action=user_data.action,\n            timestamp=user_data.timestamp\n        )\n\n        # Send to user's room using WebSocket\n        await notification.send(f\"user-{user_data.user_id}\")\n</code></pre>"},{"location":"messagebus/#command-line-usage","title":"Command Line Usage","text":"<p>You can start a message bus worker using the Jararaca CLI:</p> <pre><code>jararaca worker APP_PATH [OPTIONS]\n</code></pre> <p>Options:</p> <ul> <li><code>--broker-url</code>: The URL for the message broker (required) [env: BROKER_URL]</li> <li><code>--backend-url</code>: The URL for the message broker backend (required) [env: BACKEND_URL]</li> <li><code>--handlers</code>: Comma-separated list of handler names to listen to (optional) [env: HANDLERS]</li> <li><code>--reload</code>: Enable auto-reload when Python files change (for development) [env: RELOAD]</li> <li><code>--src-dir</code>: The source directory to watch for changes when --reload is enabled (default: \"src\") [env: SRC_DIR]</li> </ul> <p>Examples:</p> <pre><code># Standard worker execution\njararaca worker myapp.main:app --broker-url \"amqp://guest:guest@localhost:5672/?exchange=jararaca\" --backend-url \"redis://localhost:6379\"\n\n# With auto-reload for development\njararaca worker myapp.main:app --broker-url \"amqp://guest:guest@localhost:5672/?exchange=jararaca\" --backend-url \"redis://localhost:6379\" --reload\n\n# Using environment variables\nexport APP_PATH=\"myapp.main:app\"\nexport BROKER_URL=\"amqp://guest:guest@localhost:5672/?exchange=jararaca\"\nexport BACKEND_URL=\"redis://localhost:6379\"\nexport RELOAD=\"true\"\nexport SRC_DIR=\"src\"\nexport RELOAD=\"true\"\njararaca worker\n</code></pre>"},{"location":"messagebus/#environment-variable-configuration","title":"Environment Variable Configuration","text":"<p>Jararaca allows you to configure default values for message handlers through environment variables. This is useful for setting global defaults across your application without modifying code.</p>"},{"location":"messagebus/#message-handler-default-values","title":"Message Handler Default Values","text":"<p>The following environment variables control the default behavior of <code>@MessageHandler</code> decorated functions:</p> Environment Variable Type Default Description <code>JARARACA_MESSAGEBUS_HANDLER_TIMEOUT</code> <code>int</code> <code>30</code> Default timeout in seconds for message handler execution. Set to <code>0</code> or empty to disable timeout (returns <code>None</code>). <code>JARARACA_MESSAGEBUS_NACK_ON_EXCEPTION</code> <code>bool</code> <code>false</code> Whether to send a negative acknowledgment (NACK) when an exception occurs during message processing. Truthy values: <code>1</code>, <code>true</code>, <code>yes</code>, <code>on</code>. <code>JARARACA_MESSAGEBUS_AUTO_ACK</code> <code>bool</code> <code>false</code> Whether to automatically acknowledge messages after successful processing. Truthy values: <code>1</code>, <code>true</code>, <code>yes</code>, <code>on</code>. <code>JARARACA_MESSAGEBUS_NACK_DELAY_ON_EXCEPTION</code> <code>float</code> <code>5.0</code> Delay in seconds before sending a NACK when an exception occurs. Set to <code>0</code> or empty to use default of <code>5.0</code>."},{"location":"messagebus/#usage-example","title":"Usage Example","text":"<pre><code># Set global defaults for all message handlers\nexport JARARACA_MESSAGEBUS_HANDLER_TIMEOUT=60\nexport JARARACA_MESSAGEBUS_NACK_ON_EXCEPTION=true\nexport JARARACA_MESSAGEBUS_AUTO_ACK=true\nexport JARARACA_MESSAGEBUS_NACK_DELAY_ON_EXCEPTION=10.0\n\n# Start the worker\njararaca worker myapp.main:app --broker-url \"amqp://...\" --backend-url \"redis://...\"\n</code></pre>"},{"location":"messagebus/#per-handler-override","title":"Per-Handler Override","text":"<p>Environment variable defaults can be overridden on a per-handler basis by explicitly setting the parameters in the <code>@MessageHandler</code> decorator:</p> <pre><code>from jararaca import MessageBusController, MessageHandler, MessageOf\n\n\n@MessageBusController()\nclass MyController:\n    # Uses environment variable defaults\n    @MessageHandler(MyMessage)\n    async def handler_with_defaults(self, message: MessageOf[MyMessage]):\n        ...\n\n    # Overrides environment variable defaults\n    @MessageHandler(\n        MyMessage,\n        timeout=120,\n        nack_on_exception=False,\n        auto_ack=True,\n        nack_delay_on_exception=2.0\n    )\n    async def handler_with_custom_config(self, message: MessageOf[MyMessage]):\n        ...\n</code></pre>"},{"location":"messagebus/#conclusion","title":"Conclusion","text":"<p>The Jararaca message bus system provides a powerful, type-safe way to implement asynchronous processing in your applications. With its integration with other Jararaca components, it enables building distributed systems with unified context and utilities across different runtime environments.</p>"},{"location":"metadata/","title":"Metadata and Decorators","text":"<p>Jararaca provides a robust system for handling metadata and creating custom decorators that preserve context across the application lifecycle. This system is particularly useful for implementing cross-cutting concerns like authorization, logging, and transaction management.</p>"},{"location":"metadata/#metadata-system","title":"Metadata System","text":"<p>The metadata system allows you to attach arbitrary data to your controllers and methods, which can then be accessed during the request lifecycle.</p>"},{"location":"metadata/#setting-metadata","title":"Setting Metadata","text":"<p>You can use the <code>SetMetadata</code> decorator to attach metadata to a class or method.</p> <pre><code>from jararaca.reflect.metadata import SetMetadata\n\n\n@SetMetadata(\"role\", \"admin\")\nclass AdminController:\n    pass\n</code></pre>"},{"location":"metadata/#accessing-metadata","title":"Accessing Metadata","text":"<p>Metadata is stored in a context-aware storage that propagates through the request lifecycle. You can access it using helper functions:</p> <pre><code>from jararaca.reflect.metadata import get_metadata, get_metadata_value\n\n# Get the full metadata object\nmetadata = get_metadata(\"role\")\nif metadata:\n    print(metadata.value)  # \"admin\"\n    print(metadata.inherited_from_controller)  # False\n\n# Get just the value (with optional default)\nrole = get_metadata_value(\"role\", default=\"guest\")\n</code></pre>"},{"location":"metadata/#transaction-metadata-context","title":"Transaction Metadata Context","text":"<p>The metadata system is built on top of <code>ContextVar</code> and is designed to work within the Unit of Work (UoW) context. When a request starts, the framework initializes a metadata context that includes:</p> <ol> <li>Metadata defined on the controller class</li> <li>Metadata defined on the handler method</li> <li>Dynamic metadata added during execution</li> </ol> <p>You can manually manage this context using <code>start_transaction_metadata_context</code> or <code>start_providing_metadata</code>:</p> <pre><code>from jararaca.reflect.metadata import start_providing_metadata\n\n\nasync def background_task():\n    # Start a new metadata context\n    with start_providing_metadata(request_id=\"123\"):\n        # Code here can access \"request_id\" via get_metadata_value\n        process_data()\n</code></pre>"},{"location":"metadata/#custom-decorators","title":"Custom Decorators","text":"<p>When creating custom decorators for your controllers, it's crucial to preserve the metadata and controller member information. Jararaca provides utilities to help with this.</p>"},{"location":"metadata/#composing-decorators","title":"Composing Decorators","text":"<p>The <code>compose_route_decorators</code> function allows you to combine multiple middlewares and dependencies into a single reusable decorator.</p> <pre><code>from jararaca.presentation.decorators import compose_route_decorators, UseMiddleware\nfrom my_app.middleware import AuthMiddleware, RateLimitMiddleware\n\n# Create a composite decorator\nRequireAdmin = compose_route_decorators(\n    UseMiddleware(AuthMiddleware),\n    UseMiddleware(RateLimitMiddleware),\n)\n\n@RestController(\"/admin\")\nclass AdminController:\n    @Get(\"/users\")\n    @RequireAdmin  # Applies both middlewares\n    async def get_users(self):\n        pass\n</code></pre>"},{"location":"metadata/#preserving-controller-context","title":"Preserving Controller Context","text":"<p>If you're writing a decorator that wraps the handler function, you must ensure that the controller member context is preserved. Use <code>wraps_with_member_data</code> or <code>providing_controller_member</code> for this purpose.</p> <pre><code>from functools import wraps\n\nfrom jararaca.presentation.decorators import (\n    providing_controller_member,\n    use_controller_member,\n)\n\n\ndef MyCustomDecorator(func):\n    @wraps(func)\n    async def wrapper(*args, **kwargs):\n        # Access current controller member info\n        member = use_controller_member()\n        print(f\"Executing {member.member_function.__name__}\")\n\n        # If you need to execute the function in a new context (e.g. background task)\n        # you should re-provide the member context\n        with providing_controller_member(member):\n            return await func(*args, **kwargs)\n\n    return wrapper\n</code></pre>"},{"location":"metadata/#wraps_with_attributes","title":"<code>wraps_with_attributes</code>","text":"<p>For simple attribute copying, you can use <code>wraps_with_attributes</code>:</p> <pre><code>from jararaca.presentation.decorators import wraps_with_attributes\n\n\ndef Tag(name: str):\n    def decorator(func):\n        return wraps_with_attributes(func, __tag__=name)\n    return decorator\n</code></pre>"},{"location":"observability/","title":"Observability","text":"<p>Jararaca provides built-in observability support using OpenTelemetry. It allows you to trace requests across your microservices, collect metrics, and correlate logs with traces.</p>"},{"location":"observability/#configuration","title":"Configuration","text":"<p>To enable observability, you need to add the <code>ObservabilityInterceptor</code> to your microservice configuration. You can use the <code>OtelObservabilityProvider</code> to configure the OpenTelemetry exporters.</p> <pre><code>import os\n\nfrom jararaca import Microservice, ObservabilityInterceptor, OtelObservabilityProvider\n\napp = Microservice(\n    # ... other configuration ...\n    interceptors=[\n        ObservabilityInterceptor(\n            OtelObservabilityProvider.from_url(\n                app_name=\"my-service\",\n                url=os.getenv(\"OTEL_ENDPOINT\", \"http://localhost:4318\"),\n            )\n        )\n    ],\n)\n</code></pre> <p>The <code>OtelObservabilityProvider.from_url</code> helper configures the OTLP exporters for traces, metrics, and logs to the specified URL.</p>"},{"location":"observability/#context-attributes","title":"Context Attributes","text":"<p>Jararaca automatically enriches your traces and logs with context-specific attributes. This is handled by the <code>extract_context_attributes</code> function, which extracts relevant information based on the current execution context.</p>"},{"location":"observability/#http-context","title":"HTTP Context","text":"<p>For HTTP requests, the following attributes are added:</p> <ul> <li><code>http.method</code>: HTTP method (GET, POST, etc.)</li> <li><code>http.url</code>: Full URL</li> <li><code>http.path</code>: URL path</li> <li><code>http.route.path</code>: Matched route path</li> <li><code>http.route.endpoint.name</code>: Name of the endpoint function</li> <li><code>http.query</code>: Query string</li> <li><code>http.request.path_param.*</code>: All path parameters</li> <li><code>http.request.query_param.*</code>: All query parameters</li> <li><code>http.request.header.*</code>: All request headers</li> <li><code>http.request.client.host</code>: Client IP address</li> <li><code>http.request.body</code>: Request body (truncated to 5000 chars)</li> </ul>"},{"location":"observability/#message-bus-context","title":"Message Bus Context","text":"<p>For message bus handlers:</p> <ul> <li><code>bus.topic</code>: Message topic</li> <li><code>bus.message.body</code>: Message payload (JSON)</li> <li><code>bus.message.name</code>: Message class name</li> <li><code>bus.message.module</code>: Message class module</li> </ul>"},{"location":"observability/#websocket-context","title":"WebSocket Context","text":"<p>For WebSocket connections:</p> <ul> <li><code>ws.url</code>: WebSocket URL</li> </ul>"},{"location":"observability/#scheduler-context","title":"Scheduler Context","text":"<p>For scheduled tasks:</p> <ul> <li><code>sched.task_name</code>: Name of the task</li> <li><code>sched.scheduled_to</code>: Scheduled execution time</li> <li><code>sched.cron_expression</code>: Cron expression</li> <li><code>sched.triggered_at</code>: Actual trigger time</li> </ul>"},{"location":"observability/#tracing-decorators","title":"Tracing Decorators","text":"<p>You can use the <code>@TracedFunc</code> decorator to create custom spans for your functions.</p> <pre><code>from jararaca import TracedFunc\n\n\nclass MyService:\n    @TracedFunc(\"my-operation\")\n    async def perform_operation(self):\n        # This code will run within a child span named \"my-operation\"\n        pass\n</code></pre>"},{"location":"observability/#logging-integration","title":"Logging Integration","text":"<p>Jararaca integrates with the Python <code>logging</code> module. When observability is enabled, logs are automatically correlated with the current trace context. The <code>CustomLoggingHandler</code> ensures that all the context attributes mentioned above are also attached to your log records.</p> <p>This means you can filter logs by <code>http.path</code>, <code>bus.topic</code>, or any other context attribute in your observability backend (e.g., Jaeger, Grafana Tempo, Signoz).</p>"},{"location":"observability/#class-level-tracing","title":"Class-level Tracing","text":"<p>In addition to <code>@TracedFunc</code>, you can use the <code>@TracedClass</code> (or <code>@traced_class</code>) decorator to automatically trace all async methods within a class. This is useful for services or repositories where you want visibility into all operations without decorating each method individually.</p> <pre><code>from jararaca import traced_class\n\n\n@traced_class(trace_name_prefix=\"UserService\")\nclass UserService:\n    async def get_user(self, user_id: str):\n        # Traced as \"UserService.get_user\"\n        pass\n\n    async def create_user(self, data: dict):\n        # Traced as \"UserService.create_user\"\n        pass\n\n    def helper(self):\n        # Not traced (sync method)\n        pass\n</code></pre> <p>You can exclude specific methods or include private methods using the <code>exclude_methods</code> and <code>include_private</code> arguments.</p>"},{"location":"observability/#manual-instrumentation","title":"Manual Instrumentation","text":"<p>For more granular control, Jararaca provides a set of hooks in <code>jararaca.observability.hooks</code> to interact with the current trace context manually.</p>"},{"location":"observability/#creating-spans","title":"Creating Spans","text":"<p>Use <code>start_span</code> as a context manager to create a new child span.</p> <pre><code>from jararaca import start_span\n\n\nasync def complex_logic():\n    with start_span(\"step-1\", attributes={\"custom.attr\": \"value\"}):\n        # Do work\n        pass\n</code></pre>"},{"location":"observability/#adding-events","title":"Adding Events","text":"<p>You can add point-in-time events to the current span.</p> <pre><code>from jararaca import add_event\n\nadd_event(\"cache-miss\", attributes={\"key\": \"user:123\"})\n</code></pre>"},{"location":"observability/#recording-exceptions","title":"Recording Exceptions","text":"<p>To explicitly record an exception in the current span:</p> <pre><code>from jararaca import record_exception\n\ntry:\n    ...\nexcept ValueError as e:\n    record_exception(e)\n    raise\n</code></pre>"},{"location":"observability/#setting-status-and-attributes","title":"Setting Status and Attributes","text":"<p>You can also update the current span's status or add attributes dynamically.</p> <pre><code>from jararaca import set_span_status, set_span_attribute\n\nset_span_attribute(\"user.id\", user_id)\nset_span_status(\"ERROR\")\n</code></pre>"},{"location":"observability/#exception-handling","title":"Exception Handling","text":"<p>Jararaca automatically configures FastAPI exception handlers to include the trace ID in the response headers. If an error occurs, the response will contain a <code>traceparent</code> header (or the configured trace header name), allowing you to easily correlate client-side errors with backend traces.</p>"},{"location":"persistence/","title":"Database Persistence","text":"<p>Jararaca provides robust database persistence capabilities through SQLAlchemy with async support. The framework includes session management, transaction handling, and automatic integration with the interceptor system for atomic operations.</p>"},{"location":"persistence/#core-components","title":"Core Components","text":""},{"location":"persistence/#1-aiosqlalchemysessioninterceptor","title":"1. AIOSqlAlchemySessionInterceptor","text":"<p>The main interceptor that provides database session management across all application contexts (HTTP, Message Bus, Scheduler).</p> <pre><code>from jararaca import AIOSQAConfig, AIOSqlAlchemySessionInterceptor, Microservice\n\napp = Microservice(\n    name=\"my-service\",\n    interceptors=[\n        AIOSqlAlchemySessionInterceptor(\n            AIOSQAConfig(\n                connection_name=\"default\",\n                url=\"postgresql+asyncpg://user:password@localhost/mydb\",\n                inject_default=True,\n            )\n        )\n    ],\n    controllers=[...]\n)\n</code></pre>"},{"location":"persistence/#2-session-context-management","title":"2. Session Context Management","text":"<p>Jararaca provides context-based session management that ensures proper transaction handling:</p>"},{"location":"persistence/#use_session-get-current-session","title":"<code>use_session()</code> - Get Current Session","text":"<p>Access the current database session from anywhere in your application:</p> <pre><code>from jararaca import use_session\n\n\nasync def create_user(user_data: dict):\n    session = use_session()\n\n    new_user = User(**user_data)\n    session.add(new_user)\n\n    # Transaction is automatically committed by the interceptor\n    return new_user\n</code></pre>"},{"location":"persistence/#providing_new_session-spawn-new-transaction","title":"<code>providing_new_session()</code> - Spawn New Transaction","text":"<p>Create a new independent session within the current transaction context:</p> <pre><code>from jararaca import providing_new_session\n\n\nasync def create_audit_log(action: str):\n    # This creates a new session independent of the main transaction\n    async with providing_new_session() as audit_session:\n        audit_log = AuditLog(action=action)\n        audit_session.add(audit_log)\n        # This session commits independently\n</code></pre> <p>Use cases for <code>providing_new_session()</code>: - Creating audit logs that should persist even if the main transaction fails - Batch operations that need independent commits - Background tasks that need their own transaction scope</p>"},{"location":"persistence/#3-sessionmanager-protocol","title":"3. SessionManager Protocol","text":"<p>The <code>SessionManager</code> protocol defines the interface for session management:</p> <pre><code>from typing import Protocol\n\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\n\nclass SessionManager(Protocol):\n    def spawn_session(self, connection_name: str | None = None) -&gt; AsyncSession: ...\n</code></pre> <p>Access the session manager directly when needed:</p> <pre><code># use_session_manager is not exported by jararaca, so we import it from the module\nfrom jararaca.persistence.interceptors.aiosqa_interceptor import use_session_manager\n\n\nasync def advanced_session_handling():\n    session_manager = use_session_manager()\n\n    # Spawn a new session for a specific connection\n    new_session = session_manager.spawn_session(\"secondary_db\")\n</code></pre>"},{"location":"persistence/#entity-models","title":"Entity Models","text":""},{"location":"persistence/#baseentity","title":"BaseEntity","text":"<p>All entity models should inherit from <code>BaseEntity</code>:</p> <pre><code>from sqlalchemy import String\nfrom sqlalchemy.orm import Mapped, mapped_column\n\nfrom jararaca import BaseEntity\n\n\nclass User(BaseEntity):\n    __tablename__ = \"users\"\n\n    id: Mapped[str] = mapped_column(String, primary_key=True)\n    name: Mapped[str] = mapped_column(String)\n    email: Mapped[str] = mapped_column(String, unique=True)\n</code></pre>"},{"location":"persistence/#datedentity","title":"DatedEntity","text":"<p>For entities with timestamp tracking:</p> <pre><code>from sqlalchemy import String\nfrom sqlalchemy.orm import Mapped, mapped_column\n\nfrom jararaca import DatedEntity\n\n\nclass Article(DatedEntity):\n    __tablename__ = \"articles\"\n\n    id: Mapped[str] = mapped_column(String, primary_key=True)\n    title: Mapped[str] = mapped_column(String)\n    content: Mapped[str] = mapped_column(String)\n    # created_at is set on creation\n    # updated_at is set on creation and automatically updated on modification\n</code></pre>"},{"location":"persistence/#identifiableentity","title":"IdentifiableEntity","text":"<p>For entities with UUID primary keys:</p> <pre><code>from sqlalchemy import String\nfrom sqlalchemy.orm import Mapped, mapped_column\n\nfrom jararaca import IdentifiableEntity\n\n\nclass Product(IdentifiableEntity):\n    __tablename__ = \"products\"\n\n    # id is automatically provided as UUID\n    name: Mapped[str] = mapped_column(String)\n    price: Mapped[float]\n</code></pre>"},{"location":"persistence/#pydantic-integration","title":"Pydantic Integration","text":""},{"location":"persistence/#converting-between-models","title":"Converting Between Models","text":"<p>BaseEntity provides methods for seamless Pydantic integration:</p> <pre><code>from pydantic import BaseModel\n\n\nclass UserSchema(BaseModel):\n    id: str\n    name: str\n    email: str\n\n# Entity to Pydantic\nuser_entity = User(id=\"1\", name=\"John\", email=\"john@example.com\")\nuser_schema = user_entity.to_basemodel(UserSchema)\n\n# Pydantic to Entity\nuser_data = UserSchema(id=\"2\", name=\"Jane\", email=\"jane@example.com\")\nuser_entity = User.from_basemodel(user_data)\n</code></pre>"},{"location":"persistence/#multiple-database-connections","title":"Multiple Database Connections","text":"<p>Configure multiple database connections for different purposes:</p> <pre><code>app = Microservice(\n    name=\"my-service\",\n    interceptors=[\n        # Primary database\n        AIOSqlAlchemySessionInterceptor(\n            AIOSQAConfig(\n                connection_name=\"default\",\n                url=\"postgresql+asyncpg://user:pass@localhost/main_db\",\n                inject_default=True,\n            )\n        ),\n        # Analytics database\n        AIOSqlAlchemySessionInterceptor(\n            AIOSQAConfig(\n                connection_name=\"analytics\",\n                url=\"postgresql+asyncpg://user:pass@localhost/analytics_db\",\n            )\n        ),\n    ],\n)\n</code></pre> <p>Access different connections:</p> <pre><code># Default connection\nsession = use_session()\n\n# Specific connection\nanalytics_session = use_session(\"analytics\")\n</code></pre>"},{"location":"persistence/#transaction-management","title":"Transaction Management","text":""},{"location":"persistence/#automatic-transaction-handling","title":"Automatic Transaction Handling","text":"<p>By default, transactions are automatically managed by the interceptor:</p> <pre><code>@RestController(\"/api/users\")\nclass UserController:\n    @Post(\"/\")\n    async def create_user(self, user: UserCreate) -&gt; UserResponse:\n        session = use_session()\n\n        user_entity = User.from_basemodel(user)\n        session.add(user_entity)\n\n        # Transaction commits automatically at the end of the request\n        return user_entity.to_basemodel(UserResponse)\n</code></pre>"},{"location":"persistence/#manual-transaction-control","title":"Manual Transaction Control","text":"<p>For explicit control over transactions:</p> <pre><code>async def complex_operation():\n    session = use_session()\n\n    try:\n        # Your operations\n        user = User(name=\"John\")\n        session.add(user)\n\n        # Explicit commit\n        await session.commit()\n    except Exception as e:\n        # Explicit rollback\n        await session.rollback()\n        raise\n</code></pre>"},{"location":"persistence/#nested-sessions","title":"Nested Sessions","text":"<p>Create nested transactions for complex operations:</p> <pre><code>async def main_operation():\n    session = use_session()\n\n    # Main operation\n    user = User(name=\"John\")\n    session.add(user)\n\n    # Independent nested transaction\n    async with providing_new_session() as nested_session:\n        audit = AuditLog(action=\"user_created\")\n        nested_session.add(audit)\n        # Commits independently\n\n    # Main transaction continues\n</code></pre>"},{"location":"persistence/#query-operations","title":"Query Operations","text":"<p>Jararaca provides utilities for common query patterns:</p>"},{"location":"persistence/#queryoperations","title":"QueryOperations","text":"<p>Base class for query operations with filtering and pagination:</p> <pre><code>from sqlalchemy import select\n\nfrom jararaca import QueryOperations\n\n\nclass UserQueries(QueryOperations[User, UserFilter]):\n    async def list_users(self, filter: UserFilter):\n        session = use_session()\n\n        stmt = select(User)\n        stmt = self.apply_filters(stmt, filter)\n\n        result = await session.execute(stmt)\n        return result.scalars().all()\n</code></pre>"},{"location":"persistence/#pagination","title":"Pagination","text":"<p>Built-in pagination support:</p> <pre><code>from jararaca import Paginated, PaginatedFilter\n\n\nasync def get_paginated_users(filter: PaginatedFilter):\n    session = use_session()\n\n    stmt = select(User)\n\n    # Apply pagination\n    total = await session.scalar(select(func.count()).select_from(User))\n    stmt = stmt.offset(filter.offset).limit(filter.page_size)\n\n    result = await session.execute(stmt)\n    users = result.scalars().all()\n\n    return Paginated(\n        items=users,\n        total=total,\n        page=filter.page,\n        page_size=filter.page_size\n    )\n</code></pre>"},{"location":"persistence/#integration-with-transactional-outbox-pattern","title":"Integration with Transactional Outbox Pattern","text":"<p>The session interceptor automatically integrates with message publishing for transactional outbox:</p> <pre><code>from jararaca import use_publisher, use_session\n\n\nasync def create_order(order_data: dict):\n    session = use_session()\n    publisher = use_publisher()\n\n    # Create order in database\n    order = Order(**order_data)\n    session.add(order)\n\n    # Stage message for publishing\n    await publisher.publish(OrderCreatedEvent(order_id=order.id))\n\n    # Order of execution:\n    # 1. Database transaction commits\n    # 2. If successful, message is published\n    # 3. If DB fails, message is never published\n</code></pre>"},{"location":"persistence/#configuration-options","title":"Configuration Options","text":""},{"location":"persistence/#aiosqaconfig","title":"AIOSQAConfig","text":"<pre><code>@dataclass\nclass AIOSQAConfig:\n    connection_name: str              # Unique identifier for the connection\n    url: str                          # Database URL\n    inject_default: bool = False      # Set as default connection\n    echo: bool = False                # Enable SQL query logging\n    pool_size: int = 5                # Connection pool size\n    max_overflow: int = 10            # Max overflow connections\n    pool_timeout: float = 30.0        # Pool timeout in seconds\n    pool_recycle: int = 3600          # Recycle connections after N seconds\n</code></pre>"},{"location":"persistence/#example-with-full-configuration","title":"Example with Full Configuration","text":"<pre><code>AIOSqlAlchemySessionInterceptor(\n    AIOSQAConfig(\n        connection_name=\"default\",\n        url=\"postgresql+asyncpg://user:pass@localhost/db\",\n        inject_default=True,\n        echo=True,  # Enable SQL logging in development\n        pool_size=10,\n        max_overflow=20,\n        pool_timeout=30.0,\n        pool_recycle=3600,\n    )\n)\n</code></pre>"},{"location":"persistence/#best-practices","title":"Best Practices","text":"<ol> <li>Use Context Hooks: Always use <code>use_session()</code> to access the session instead of creating sessions manually</li> <li>Let Interceptor Manage Transactions: Rely on automatic transaction management unless you have a specific reason not to</li> <li>Use <code>providing_new_session()</code> for Independent Operations: Audit logs, background tasks, and operations that should succeed regardless of the main transaction</li> <li>Connection Names: Use meaningful names for multiple connections (e.g., \"default\", \"analytics\", \"cache\")</li> <li>Entity Base Classes: Inherit from <code>BaseEntity</code>, <code>DatedEntity</code>, or <code>IdentifiableEntity</code> for consistent behavior</li> <li>Pydantic Integration: Use <code>to_basemodel()</code> and <code>from_basemodel()</code> for type-safe conversions</li> </ol>"},{"location":"persistence/#error-handling","title":"Error Handling","text":"<pre><code>from sqlalchemy.exc import IntegrityError\n\n\nasync def create_user_safe(user_data: dict):\n    session = use_session()\n\n    try:\n        user = User(**user_data)\n        session.add(user)\n        await session.flush()  # Check for errors before commit\n\n        return user\n    except IntegrityError as e:\n        # Handle duplicate key, etc.\n        await session.rollback()\n        raise ValueError(f\"User already exists: {e}\")\n</code></pre>"},{"location":"persistence/#testing","title":"Testing","text":"<p>For testing, you can provide a test database configuration:</p> <pre><code>import pytest\n\nfrom jararaca import AIOSQAConfig, AIOSqlAlchemySessionInterceptor, Microservice\n\n\n@pytest.fixture\nasync def test_app():\n    app = Microservice(\n        name=\"test-service\",\n        interceptors=[\n            AIOSqlAlchemySessionInterceptor(\n                AIOSQAConfig(\n                    connection_name=\"test\",\n                    url=\"sqlite+aiosqlite:///:memory:\",\n                    inject_default=True,\n                )\n            )\n        ],\n    )\n    return app\n</code></pre>"},{"location":"persistence/#conclusion","title":"Conclusion","text":"<p>Jararaca's persistence layer provides a powerful and flexible way to work with databases while maintaining consistency with message publishing and WebSocket communications through the transactional outbox pattern. The context-based session management ensures clean code and automatic transaction handling across all application contexts.</p>"},{"location":"retry/","title":"Retry Mechanism with Exponential Backoff","text":"<p>Jararaca implements a robust retry mechanism with exponential backoff for handling transient failures in RabbitMQ connections and operations. This mechanism helps the system gracefully handle temporary network issues, broker unavailability, and other transient failures.</p>"},{"location":"retry/#core-components","title":"Core Components","text":"<p>The retry system consists of these main components:</p> <ol> <li><code>RPCRetryPolicy</code> - Configuration class for customizing retry behavior</li> <li><code>retry_with_backoff</code> - Utility function to execute operations with retry</li> <li><code>with_retry</code> - Decorator for applying retry logic to functions</li> </ol>"},{"location":"retry/#retry-configuration","title":"Retry Configuration","text":"<p>The <code>RPCRetryPolicy</code> class allows customization of various retry parameters:</p> <pre><code>class RPCRetryPolicy:\n    def __init__(\n        self,\n        max_retries: int = 5,         # Maximum number of retry attempts\n        initial_delay: float = 1.0,    # Initial delay between retries (seconds)\n        max_delay: float = 60.0,       # Maximum delay between retries (seconds)\n        backoff_factor: float = 2.0,   # Multiplier for delay after each retry\n        jitter: bool = True,           # Add randomness to delay to prevent thundering herd\n    ):\n        ...\n</code></pre>"},{"location":"retry/#integration-with-messagebus-worker","title":"Integration with MessageBus Worker","text":"<p>The RabbitMQ consumer in the message bus system uses the retry mechanism in several key areas:</p> <ol> <li> <p>Connection Establishment: When establishing a connection to RabbitMQ, the system will automatically retry with increasing backoff periods if the connection fails.</p> </li> <li> <p>Channel Creation: When creating channels for publishing or consuming messages, failures trigger the retry mechanism.</p> </li> <li> <p>Consumer Setup: Setting up message consumers uses retry logic to handle temporary failures.</p> </li> </ol>"},{"location":"retry/#url-configuration-parameters","title":"URL Configuration Parameters","text":"<p>Retry behavior can be customized through URL parameters when configuring the RabbitMQ connection:</p> Parameter Description Default <code>connection_retry_max</code> Maximum number of connection retry attempts 5 <code>connection_retry_delay</code> Initial delay between connection retries (seconds) 1.0 <code>connection_retry_max_delay</code> Maximum delay between connection retries (seconds) 60.0 <code>connection_retry_backoff</code> Multiplier for delay after each connection retry 2.0 <code>consumer_retry_max</code> Maximum number of consumer setup retry attempts 3 <code>consumer_retry_delay</code> Initial delay between consumer setup retries (seconds) 0.5 <code>consumer_retry_max_delay</code> Maximum delay between consumer setup retries (seconds) 5.0 <code>consumer_retry_backoff</code> Multiplier for delay after each consumer setup retry 2.0"},{"location":"retry/#example-usage","title":"Example Usage","text":"<pre><code># Configure with custom retry settings in URL:\nbroker_url = \"amqp://guest:guest@localhost:5672/?exchange=jararaca&amp;prefetch_count=10&amp;connection_retry_max=10&amp;connection_retry_delay=2.0\"\n\n# Use custom retry configuration in code:\nfrom jararaca import RPCRetryPolicy, retry\n\nconfig = RPCRetryPolicy(max_retries=3, initial_delay=1.0, max_delay=30.0)\n\nasync def connect_with_retry():\n    return await retry(\n        establish_connection,\n        retry_config=config,\n        retry_exceptions=(ConnectionError, TimeoutError)\n    )\n</code></pre>"},{"location":"retry/#benefits","title":"Benefits","text":"<ol> <li>Resilience - The system can recover automatically from transient failures</li> <li>Reduced downtime - Automatic reconnection minimizes service disruption</li> <li>Configuration flexibility - Retry behavior can be tailored to different environments</li> <li>Smart backoff - Exponential backoff with jitter prevents overloading services during recovery</li> </ol>"},{"location":"scheduler/","title":"Jararaca Scheduler System","text":"<p>The scheduler system in Jararaca provides robust task scheduling capabilities that allow you to run periodic tasks using cron expressions. This document explains how the scheduler works, its different implementations, and how to use it in your applications.</p>"},{"location":"scheduler/#overview","title":"Overview","text":"<p>The Jararaca scheduler allows you to:</p> <ul> <li>Run background tasks at scheduled intervals</li> <li>Use cron expressions for flexible scheduling</li> <li>Control overlap behavior (whether to allow multiple instances of the same task)</li> <li>Distribute scheduled tasks across multiple instances</li> <li>Handle delayed message execution</li> </ul> <p>The scheduler is implemented through the BeatWorker which provides distributed task scheduling via a message broker:</p> <pre><code>graph TD\n    A[Microservice] --&gt; B[BeatWorker]\n    B --&gt; C[Message Broker]\n    B --&gt; D[Backend Store]\n    C --&gt; E[Message Processing]\n    D --&gt; F[Last Execution Time]\n    D --&gt; G[Delayed Messages]\n</code></pre>"},{"location":"scheduler/#using-the-scheduler","title":"Using the Scheduler","text":""},{"location":"scheduler/#defining-scheduled-tasks","title":"Defining Scheduled Tasks","text":"<p>You can define scheduled tasks using the <code>@ScheduledAction</code> decorator:</p> <pre><code>from jararaca import ScheduledAction\n\n\nclass TasksController:\n    @ScheduledAction(\"*/5 * * * *\")  # Run every 5 minutes\n    async def scheduled_task(self):\n        # Your task implementation\n        print(\"This runs every 5 minutes\")\n\n    @ScheduledAction(\"0 */2 * * *\", allow_overlap=False, timeout=60)\n    async def heavy_task(self):\n        # A heavier task that shouldn't overlap\n        print(\"This runs every 2 hours without overlap\")\n</code></pre>"},{"location":"scheduler/#scheduler-decorator-options","title":"Scheduler Decorator Options","text":"<p>The <code>@ScheduledAction</code> decorator accepts several parameters:</p> <ul> <li><code>cron</code>: A string representing the cron expression for the scheduled action</li> <li><code>allow_overlap</code>: A boolean indicating if new executions should start even if the previous one is still running (default: <code>False</code>)</li> <li><code>exclusive</code>: A boolean indicating if the scheduled action should be executed in only one instance of the application (requires a distributed backend, default: <code>True</code>)</li> <li><code>timeout</code>: An integer representing the timeout for the scheduled action in seconds (default: <code>None</code>)</li> <li><code>exception_handler</code>: A callable that will be called when an exception is raised during execution (default: <code>None</code>)</li> </ul>"},{"location":"scheduler/#cron-expressions","title":"Cron Expressions","text":"<p>Jararaca uses standard cron expressions for scheduling. Here are some examples:</p> <ul> <li><code>* * * * *</code> - Run every minute</li> <li><code>*/15 * * * *</code> - Run every 15 minutes</li> <li><code>0 * * * *</code> - Run at the beginning of every hour</li> <li><code>0 0 * * *</code> - Run at midnight every day</li> <li><code>0 0 * * 0</code> - Run at midnight every Sunday</li> <li><code>0 0 1 * *</code> - Run at midnight on the first day of every month</li> </ul>"},{"location":"scheduler/#using-the-beatworker-scheduler","title":"Using the BeatWorker Scheduler","text":"<p>The BeatWorker scheduler provides distributed task execution through a message broker:</p> <pre><code>from jararaca import Microservice, ScheduledAction\nfrom jararaca.scheduler.beat_worker import BeatWorker\n\napp = Microservice(\n    # Your microservice configuration\n)\n\n# Run the scheduler\nbeat_worker = BeatWorker(\n    app=app,\n    interval=1,\n    backend_url=\"redis://localhost:6379\",\n    broker_url=\"amqp://guest:guest@localhost:5672/?exchange=jararaca\",\n    scheduled_action_names=None  # Optional set of action names to run\n)\nbeat_worker.run()\n</code></pre> <p>You can also use the CLI command to run the scheduler:</p> <pre><code># Standard beat scheduler execution\njararaca beat app_module:app --interval 1 --broker-url \"amqp://guest:guest@localhost:5672/?exchange=jararaca\" --backend-url \"redis://localhost:6379\"\n\n# With auto-reload for development (automatically restarts when Python files change)\njararaca beat app_module:app --interval 1 --broker-url \"amqp://guest:guest@localhost:5672/?exchange=jararaca\" --backend-url \"redis://localhost:6379\" --reload\n\n# Using environment variables\nexport APP_PATH=\"app_module:app\"\nexport INTERVAL=\"1\"\nexport BROKER_URL=\"amqp://guest:guest@localhost:5672/?exchange=jararaca\"\nexport BACKEND_URL=\"redis://localhost:6379\"\nexport RELOAD=\"true\"\nexport SRC_DIR=\"src\"\njararaca beat\n</code></pre> <p>All command options support environment variables: - <code>APP_PATH</code>: The application module path [required] - <code>INTERVAL</code>: Polling interval in seconds [default: 1] - <code>BROKER_URL</code>: The URL for the message broker [required] - <code>BACKEND_URL</code>: The URL for the message broker backend [required] - <code>ACTIONS</code>: Comma-separated list of action names to run [optional] - <code>RELOAD</code>: Enable auto-reload when Python files change [optional] - <code>SRC_DIR</code>: The source directory to watch for changes when using reload [default: \"src\"] <pre><code>app = Microservice(\n    # Your microservice configuration\n)\n\n# Run the enhanced scheduler\nscheduler = SchedulerV2(\n    app=app,\n    interval=1,\n    broker_url=\"amqp://guest:guest@localhost:5672/?exchange=jararaca_ex\",\n    backend_url=\"redis://localhost:6379\",\n)\nscheduler.run()\n</code></pre></p>"},{"location":"scheduler/#message-broker-integration","title":"Message Broker Integration","text":"<p>The V2 scheduler uses a message broker (currently supporting RabbitMQ) to distribute tasks:</p> <ol> <li>The scheduler determines when a task should run based on its cron expression</li> <li>Instead of executing the task directly, it sends a message to the message broker</li> <li>A worker picks up the message and executes the task</li> <li>The backend store (Redis) tracks execution state to prevent overlap when configured</li> </ol> <p>This architecture allows for better scalability and reliability:</p> <pre><code>sequenceDiagram\n    participant S as SchedulerV2\n    participant B as Message Broker\n    participant R as Redis Backend\n    participant W as Worker\n\n    S-&gt;&gt;R: Check last execution time\n    R--&gt;&gt;S: Return last execution time\n    S-&gt;&gt;S: Determine if task should run\n    S-&gt;&gt;B: Publish task message\n    S-&gt;&gt;R: Update last execution time\n    B--&gt;&gt;W: Deliver task message\n    W-&gt;&gt;R: Mark task as running\n    W-&gt;&gt;W: Execute task\n    W-&gt;&gt;R: Mark task as completed\n</code></pre>"},{"location":"scheduler/#delayed-message-queue","title":"Delayed Message Queue","text":"<p>The V2 scheduler also supports delayed messages:</p> <pre><code>from jararaca import use_publisher\n\n# DelayedMessageData is not exported by jararaca, so we import it from the module\nfrom jararaca.scheduler.types import DelayedMessageData\n\n\n# Schedule a message to be published at a future time\nasync def schedule_reminder():\n    message = ReminderMessage(\n        user_id=\"123\",\n        message=\"Don't forget your appointment!\"\n    )\n\n    # Current time + 1 hour in seconds\n    dispatch_time = int(time.time()) + 3600\n\n    # Get publisher\n    publisher = use_publisher()\n\n    # Schedule delayed message\n    await publisher.publish_delayed(\n        message,\n        dispatch_time=dispatch_time\n    )\n</code></pre>"},{"location":"scheduler/#redis-backend-implementation","title":"Redis Backend Implementation","text":"<p>The Redis backend implementation provides:</p> <ol> <li>Distributed Locking - Ensures tasks only run on one instance when exclusivity is required</li> <li>Execution Tracking - Tracks the running state of tasks to prevent overlap</li> <li>Delayed Message Queue - Manages messages scheduled for future delivery</li> </ol> <p>The implementation uses Redis data structures: - Keys for last execution time and dispatch time - Sorted sets for delayed message queue - Hash sets for execution indicators</p>"},{"location":"scheduler/#running-the-scheduler","title":"Running the Scheduler","text":""},{"location":"scheduler/#cli-command-for-basic-scheduler","title":"CLI Command for Basic Scheduler","text":"<pre><code>jararaca scheduler APP_PATH [OPTIONS]\n</code></pre> <p>Options: - <code>--interval</code>: Polling interval in seconds (default: 1)</p>"},{"location":"scheduler/#cli-command-for-enhanced-scheduler-v2","title":"CLI Command for Enhanced Scheduler (V2)","text":"<pre><code>jararaca scheduler_v2 APP_PATH [OPTIONS]\n</code></pre> <p>Options: - <code>--interval</code>: Polling interval in seconds (default: 1, required) - <code>--broker-url</code>: The URL for the message broker (required) - <code>--backend-url</code>: The URL for the message broker backend (required)</p>"},{"location":"scheduler/#best-practices","title":"Best Practices","text":"<ol> <li>Task Duration - Be mindful of task duration, especially for frequent tasks</li> <li>Error Handling - Implement proper error handling in your tasks</li> <li>Overlap Control - Use <code>allow_overlap=False</code> for resource-intensive tasks</li> <li>Timeouts - Set appropriate timeouts to prevent stuck tasks</li> <li>Monitoring - Log task execution for monitoring purposes</li> </ol>"},{"location":"scheduler/#conclusion","title":"Conclusion","text":"<p>The Jararaca scheduler system provides a powerful, flexible way to implement periodic tasks in your applications. With two implementations to choose from, you can select the one that best fits your application's requirements, from simple local scheduling to complex distributed task execution.</p>"},{"location":"testing/","title":"Testing in Jararaca","text":"<p>Jararaca includes a comprehensive test suite and provides utilities for testing your microservice applications. This guide covers how to test your Jararaca applications effectively.</p>"},{"location":"testing/#running-framework-tests","title":"Running Framework Tests","text":"<p>The Jararaca framework itself comes with a full test suite:</p> <pre><code># Run all tests\npoetry run pytest\n\n# Run with coverage\npoetry run pytest --cov=src/jararaca --cov-report=html\n\n# Run specific test categories\npoetry run pytest -m unit          # Unit tests only\npoetry run pytest -m integration   # Integration tests only\n</code></pre>"},{"location":"testing/#testing-your-application","title":"Testing Your Application","text":""},{"location":"testing/#basic-test-setup","title":"Basic Test Setup","text":"<p>Create a pytest fixture for your microservice:</p> <pre><code>import pytest\n\nfrom jararaca import AIOSQAConfig, AIOSqlAlchemySessionInterceptor, Microservice\n\n\n@pytest.fixture\nasync def app():\n    \"\"\"Create a test microservice instance.\"\"\"\n    return Microservice(\n        name=\"test-service\",\n        interceptors=[\n            AIOSqlAlchemySessionInterceptor(\n                AIOSQAConfig(\n                    connection_name=\"test\",\n                    url=\"sqlite+aiosqlite:///:memory:\",\n                    inject_default=True,\n                )\n            )\n        ],\n        controllers=[YourController],\n    )\n</code></pre>"},{"location":"testing/#testing-rest-controllers","title":"Testing REST Controllers","text":"<p>Use FastAPI's TestClient for testing HTTP endpoints:</p> <pre><code>import pytest\nfrom httpx import AsyncClient\nfrom jararaca import HttpMicroservice, create_http_server\n\n@pytest.fixture\nasync def client(app):\n    \"\"\"Create test HTTP client.\"\"\"\n    http_app = HttpMicroservice(app=app)\n    server = create_http_server(http_app)\n\n    async with AsyncClient(app=server, base_url=\"http://test\") as client:\n        yield client\n\n@pytest.mark.asyncio\nasync def test_create_user(client):\n    \"\"\"Test user creation endpoint.\"\"\"\n    response = await client.post(\n        \"/api/users\",\n        json={\"name\": \"John Doe\", \"email\": \"john@example.com\"}\n    )\n\n    assert response.status_code == 201\n    data = response.json()\n    assert data[\"name\"] == \"John Doe\"\n    assert data[\"email\"] == \"john@example.com\"\n</code></pre>"},{"location":"testing/#testing-message-bus-handlers","title":"Testing Message Bus Handlers","text":"<p>Test message handlers by invoking them directly:</p> <pre><code>import pytest\nfrom jararaca import MessageOf, use_session\nfrom your_app.events import UserCreatedEvent\nfrom your_app.handlers import UserEventsController\n\n@pytest.mark.asyncio\nasync def test_user_created_handler(app):\n    \"\"\"Test user created event handler.\"\"\"\n    # Create handler instance\n    handler = UserEventsController()\n\n    # Create test message\n    event = UserCreatedEvent(user_id=\"123\", name=\"John\")\n    message = MessageOf(body=event, topic=\"user.created\")\n\n    # Execute handler\n    await handler.handle_user_created(message)\n\n    # Verify results\n    session = use_session()\n    # Assert your expectations\n</code></pre>"},{"location":"testing/#testing-scheduled-actions","title":"Testing Scheduled Actions","text":"<p>Test scheduled actions directly:</p> <pre><code>import pytest\nfrom your_app.tasks import ScheduledTasksController\n\n@pytest.mark.asyncio\nasync def test_cleanup_task(app):\n    \"\"\"Test cleanup scheduled task.\"\"\"\n    controller = ScheduledTasksController()\n\n    # Execute the scheduled action\n    await controller.cleanup_old_data()\n\n    # Verify cleanup was performed\n    session = use_session()\n    # Assert your expectations\n</code></pre>"},{"location":"testing/#testing-database-operations","title":"Testing Database Operations","text":"<p>Test database operations with in-memory SQLite:</p> <pre><code>import pytest\nfrom jararaca import use_session\nfrom your_app.models import User\n\n@pytest.mark.asyncio\nasync def test_user_repository(app):\n    \"\"\"Test user repository operations.\"\"\"\n    session = use_session()\n\n    # Create test user\n    user = User(id=\"1\", name=\"Test User\", email=\"test@example.com\")\n    session.add(user)\n    await session.flush()\n\n    # Query user\n    from sqlalchemy import select\n    result = await session.execute(select(User).where(User.id == \"1\"))\n    found_user = result.scalar_one()\n\n    assert found_user.name == \"Test User\"\n    assert found_user.email == \"test@example.com\"\n</code></pre>"},{"location":"testing/#testing-with-dependency-injection","title":"Testing with Dependency Injection","text":"<p>Test components with dependency injection:</p> <pre><code>import pytest\nfrom jararaca import Container, Microservice, ProviderSpec, Token\n\n@pytest.mark.asyncio\nasync def test_with_di():\n    \"\"\"Test component with dependency injection.\"\"\"\n    # Create mock service\n    class MockEmailService:\n        async def send(self, to: str, message: str):\n            return True\n\n    # Configure app with mock\n    app = Microservice(\n        name=\"test\",\n        providers=[\n            ProviderSpec(\n                provide=Token(EmailService, \"EMAIL_SERVICE\"),\n                use_value=MockEmailService()\n            )\n        ],\n        controllers=[YourController]\n    )\n\n    # Test your controller\n    container = Container(app)\n    controller = container.get_by_type(YourController)\n\n    result = await controller.send_notification(\n        user_id=\"123\",\n        message=\"Test\"\n    )\n\n    assert result is True\n</code></pre>"},{"location":"testing/#testing-websocket-endpoints","title":"Testing WebSocket Endpoints","text":"<p>Test WebSocket connections:</p> <pre><code>import pytest\nfrom httpx import AsyncClient\nfrom fastapi.testclient import TestClient\n\n@pytest.mark.asyncio\nasync def test_websocket_endpoint(app):\n    \"\"\"Test WebSocket connection.\"\"\"\n    http_app = create_http_server(HttpMicroservice(app=app))\n\n    with TestClient(http_app) as client:\n        with client.websocket_connect(\"/ws/chat\") as websocket:\n            # Send message\n            websocket.send_json({\"type\": \"message\", \"content\": \"Hello\"})\n\n            # Receive response\n            data = websocket.receive_json()\n            assert data[\"type\"] == \"response\"\n</code></pre>"},{"location":"testing/#testing-with-interceptors","title":"Testing with Interceptors","text":"<p>Test that interceptors work correctly:</p> <pre><code>import pytest\nfrom jararaca import use_session, use_publisher\n\n@pytest.mark.asyncio\nasync def test_transactional_outbox(app):\n    \"\"\"Test that messages are only published if DB transaction succeeds.\"\"\"\n    session = use_session()\n    publisher = use_publisher()\n\n    # Create entity\n    user = User(id=\"1\", name=\"Test\")\n    session.add(user)\n\n    # Stage message\n    await publisher.publish(UserCreatedEvent(user_id=\"1\"))\n\n    # At this point, message is staged but not published\n    # Transaction will commit and message will be published\n</code></pre>"},{"location":"testing/#mocking-external-dependencies","title":"Mocking External Dependencies","text":"<p>Use pytest fixtures to mock external services:</p> <pre><code>import pytest\nfrom unittest.mock import AsyncMock, MagicMock\n\n@pytest.fixture\ndef mock_rabbitmq():\n    \"\"\"Mock RabbitMQ connection.\"\"\"\n    mock = AsyncMock()\n    mock.publish = AsyncMock(return_value=True)\n    return mock\n\n@pytest.fixture\ndef mock_redis():\n    \"\"\"Mock Redis connection.\"\"\"\n    mock = MagicMock()\n    mock.get = MagicMock(return_value=b'{\"data\": \"cached\"}')\n    return mock\n\n@pytest.mark.asyncio\nasync def test_with_mocks(app, mock_rabbitmq, mock_redis):\n    \"\"\"Test with mocked dependencies.\"\"\"\n    # Your test using mocked dependencies\n</code></pre>"},{"location":"testing/#test-organization","title":"Test Organization","text":""},{"location":"testing/#directory-structure","title":"Directory Structure","text":"<pre><code>tests/\n\u251c\u2500\u2500 conftest.py              # Shared fixtures\n\u251c\u2500\u2500 test_controllers.py      # REST controller tests\n\u251c\u2500\u2500 test_messagebus.py       # Message bus handler tests\n\u251c\u2500\u2500 test_scheduler.py        # Scheduled task tests\n\u251c\u2500\u2500 test_repositories.py     # Database operation tests\n\u251c\u2500\u2500 test_services.py         # Business logic tests\n\u2514\u2500\u2500 test_integration.py      # End-to-end integration tests\n</code></pre>"},{"location":"testing/#using-markers","title":"Using Markers","text":"<p>Organize tests with pytest markers:</p> <pre><code>import pytest\n\n@pytest.mark.unit\ndef test_business_logic():\n    \"\"\"Fast unit test.\"\"\"\n\n@pytest.mark.integration\n@pytest.mark.asyncio\nasync def test_full_workflow():\n    \"\"\"Slower integration test.\"\"\"\n\n@pytest.mark.slow\n@pytest.mark.asyncio\nasync def test_performance():\n    \"\"\"Performance test.\"\"\"\n</code></pre> <p>Configure markers in <code>pytest.ini</code>:</p> <pre><code>[pytest]\nmarkers =\n    unit: Fast unit tests\n    integration: Integration tests\n    slow: Slow running tests\n    asyncio: Async tests\n</code></pre>"},{"location":"testing/#best-practices","title":"Best Practices","text":"<ol> <li>Use In-Memory Databases: SQLite in-memory for fast tests</li> <li>Isolate Tests: Each test should be independent</li> <li>Mock External Services: Don't make real HTTP calls or connect to external services</li> <li>Test Happy and Error Paths: Cover both success and failure scenarios</li> <li>Use Fixtures: Reuse common setup with pytest fixtures</li> <li>Async Tests: Use <code>@pytest.mark.asyncio</code> for async tests</li> <li>Clear Assertions: Make assertions specific and clear</li> <li>Test Coverage: Aim for high coverage but focus on important paths</li> </ol>"},{"location":"testing/#common-testing-patterns","title":"Common Testing Patterns","text":""},{"location":"testing/#testing-error-handling","title":"Testing Error Handling","text":"<pre><code>import pytest\nfrom fastapi import HTTPException\n\n\n@pytest.mark.asyncio\nasync def test_error_handling(client):\n    \"\"\"Test that errors are handled correctly.\"\"\"\n    response = await client.post(\n        \"/api/users\",\n        json={\"invalid\": \"data\"}\n    )\n\n    assert response.status_code == 422\n    assert \"validation error\" in response.json()[\"detail\"]\n</code></pre>"},{"location":"testing/#testing-authentication","title":"Testing Authentication","text":"<pre><code>import pytest\n\n\n@pytest.mark.asyncio\nasync def test_requires_auth(client):\n    \"\"\"Test that endpoint requires authentication.\"\"\"\n    response = await client.get(\"/api/protected\")\n    assert response.status_code == 401\n\n@pytest.mark.asyncio\nasync def test_with_auth(client):\n    \"\"\"Test authenticated request.\"\"\"\n    response = await client.get(\n        \"/api/protected\",\n        headers={\"Authorization\": \"Bearer test-token\"}\n    )\n    assert response.status_code == 200\n</code></pre>"},{"location":"testing/#testing-pagination","title":"Testing Pagination","text":"<pre><code>import pytest\n\n\n@pytest.mark.asyncio\nasync def test_pagination(client):\n    \"\"\"Test paginated endpoint.\"\"\"\n    # Create test data\n    for i in range(25):\n        await client.post(\"/api/items\", json={\"name\": f\"Item {i}\"})\n\n    # Test first page\n    response = await client.get(\"/api/items?page=1&amp;page_size=10\")\n    data = response.json()\n\n    assert len(data[\"items\"]) == 10\n    assert data[\"total\"] == 25\n    assert data[\"page\"] == 1\n</code></pre>"},{"location":"testing/#testing-with-transaction-rollback","title":"Testing with Transaction Rollback","text":"<pre><code>import pytest\n\nfrom jararaca import use_session\n\n\n@pytest.mark.asyncio\nasync def test_with_rollback(app):\n    \"\"\"Test that changes are rolled back on error.\"\"\"\n    session = use_session()\n\n    try:\n        user = User(id=\"1\", name=\"Test\")\n        session.add(user)\n        await session.flush()\n\n        # Simulate error\n        raise ValueError(\"Something went wrong\")\n    except ValueError:\n        await session.rollback()\n\n    # Verify rollback\n    from sqlalchemy import select\n    result = await session.execute(select(User).where(User.id == \"1\"))\n    assert result.scalar_one_or_none() is None\n</code></pre>"},{"location":"testing/#continuous-integration","title":"Continuous Integration","text":"<p>Example GitHub Actions workflow:</p> <pre><code>name: Tests\n\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v2\n\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.11'\n\n      - name: Install dependencies\n        run: |\n          pip install poetry\n          poetry install\n\n      - name: Run tests\n        run: |\n          poetry run pytest --cov=src --cov-report=xml\n\n      - name: Upload coverage\n        uses: codecov/codecov-action@v2\n        with:\n          file: ./coverage.xml\n</code></pre>"},{"location":"testing/#conclusion","title":"Conclusion","text":"<p>Jararaca provides a solid foundation for testing microservice applications. By following these patterns and best practices, you can build a comprehensive test suite that ensures your application works correctly across all components: HTTP APIs, message handlers, scheduled tasks, and database operations.</p>"},{"location":"typescript-generation/","title":"TypeScript Interface Generation","text":"<p>Jararaca provides a powerful tool to generate TypeScript interfaces and client code from your Python backend code. This ensures type safety across your full stack and reduces the need for manual type synchronization.</p>"},{"location":"typescript-generation/#usage","title":"Usage","text":"<p>To generate TypeScript interfaces, use the <code>gen-tsi</code> command:</p> <pre><code>jararaca gen-tsi APP_PATH OUTPUT_FILE\n</code></pre> <p>Example: <pre><code>jararaca gen-tsi app:app src/client/api.ts\n</code></pre></p>"},{"location":"typescript-generation/#features","title":"Features","text":""},{"location":"typescript-generation/#automatic-type-mapping","title":"Automatic Type Mapping","text":"<p>Pydantic models used in your controllers (request bodies, response models, query parameters) are automatically converted to TypeScript interfaces.</p>"},{"location":"typescript-generation/#controller-inheritance","title":"Controller Inheritance","text":"<p>The generator supports inheritance in controllers. If you have a base controller with endpoints and middlewares, a child controller will inherit these configurations.</p> <pre><code>@UseMiddleware(BaseMiddleware)\n@RestController(\"/base\")\nclass BaseController:\n    @Get(\"/hello\")\n    async def hello(self) -&gt; str:\n        return \"hello\"\n\n@RestController(\"/child\")\nclass ChildController(BaseController):\n    # Inherits /hello endpoint and BaseMiddleware\n    pass\n</code></pre> <p>If you override a method in the child controller without adding new decorators, it will inherit the endpoint configuration (path, method, middlewares) from the parent class.</p> <pre><code>@RestController(\"/child\")\nclass ChildController(BaseController):\n    async def hello(self) -&gt; str:\n        # Still a GET /child/hello endpoint\n        return \"child hello\"\n</code></pre>"},{"location":"typescript-generation/#explicit-type-exposure","title":"Explicit Type Exposure","text":"<p>Use the <code>@ExposeType</code> decorator to include types that aren't directly used in endpoints but are needed on the frontend. See Exposing Types for more details.</p>"},{"location":"typescript-generation/#query-and-mutation-endpoints","title":"Query and Mutation Endpoints","text":"<p>Decorate methods with <code>@QueryEndpoint</code> or <code>@MutationEndpoint</code> to generate specific hooks for data fetching libraries (like React Query).</p> <pre><code>@QueryEndpoint\n@Get(\"/items\")\nasync def get_items(self) -&gt; list[Item]:\n    ...\n</code></pre>"},{"location":"websocket/","title":"Distributed WebSocket in Jararaca","text":"<p>Jararaca provides a powerful distributed WebSocket system that enables real-time communication across multiple server instances. This document explains how the WebSocket system works, its architecture, and how to use it in your applications.</p>"},{"location":"websocket/#overview","title":"Overview","text":"<p>The WebSocket system in Jararaca is designed for scalability and ease of use, with the following key features:</p> <ul> <li>One-way communication pattern: WebSockets are used for server-to-client messages only, with client-to-server communication happening via REST API</li> <li>Room-based communication: WebSocket connections can be grouped into logical rooms for targeted messaging</li> <li>Cross-instance messaging: Messages can be broadcast across multiple server instances</li> <li>Redis-backed distribution: Uses Redis pub/sub for reliable message distribution</li> <li>Seamless integration: Works with FastAPI's WebSocket support</li> <li>Type-safe messaging: Leverages Pydantic for structured WebSocket messages</li> </ul> <pre><code>graph TD\n    A[WebSocket Client] &lt;-- Server to Client --&gt; B[Jararaca Instance 1]\n    A &lt;-- Server to Client --&gt; C[Jararaca Instance 2]\n    A &lt;-- Server to Client --&gt; D[Jararaca Instance 3]\n\n    A -- Client to Server via REST --&gt; B\n    A -- Client to Server via REST --&gt; C\n    A -- Client to Server via REST --&gt; D\n\n    B &lt;--&gt; E[Redis PubSub]\n    C &lt;--&gt; E\n    D &lt;--&gt; E\n\n    subgraph \"Distributed Communication\"\n        E\n    end\n</code></pre>"},{"location":"websocket/#architecture-components","title":"Architecture Components","text":"<p>The WebSocket system consists of several key components that work together:</p>"},{"location":"websocket/#1-websocketmessagebase","title":"1. WebSocketMessageBase","text":"<p>The base class for all WebSocket messages. Messages are structured, validated, and serialized using Pydantic.</p> <pre><code>class WebSocketMessageBase(BaseModel):\n    MESSAGE_ID: ClassVar[str] = \"__UNSET__\"\n</code></pre>"},{"location":"websocket/#2-websocketmessage","title":"2. WebSocketMessage","text":"<p>A concrete message class that adds functionality for sending messages to specific rooms.</p> <pre><code>class WebSocketMessage(WebSocketMessageBase):\n    async def send(self, *rooms: str) -&gt; None:\n        await use_ws_manager().send(list(rooms), self)\n</code></pre>"},{"location":"websocket/#3-websocketconnectionmanager","title":"3. WebSocketConnectionManager","text":"<p>A Protocol that defines the interface for managing WebSocket connections:</p> <pre><code>class WebSocketConnectionManager(Protocol):\n    async def broadcast(self, message: bytes) -&gt; None: ...\n    async def send(self, rooms: list[str], message: WebSocketMessageBase) -&gt; None: ...\n    async def join(self, rooms: list[str], websocket: WebSocket) -&gt; None: ...\n    async def add_websocket(self, websocket: WebSocket) -&gt; None: ...\n    async def remove_websocket(self, websocket: WebSocket) -&gt; None: ...\n</code></pre> <p>The WebSocketConnectionManager: - Maintains a registry of active WebSocket connections - Groups connections into named rooms - Provides methods for broadcasting and sending targeted messages</p>"},{"location":"websocket/#4-context-based-websocket-access","title":"4. Context-based WebSocket Access","text":"<p>Jararaca uses context variables to provide access to WebSocket functionality anywhere in your application:</p> <pre><code>from jararaca import use_ws_manager\n\n# Send a message to specific rooms\nasync def notify_users(message_data: dict, room_id: str):\n    message = UserNotificationMessage(**message_data)\n    # Note: use_ws_message_sender is not directly exported, use use_ws_manager instead\n    await use_ws_manager().send([room_id], message)\n\n# Or directly from a WebSocketMessage instance\nasync def send_update(update_data: dict, room_id: str):\n    message = SystemUpdateMessage(**update_data)\n    await message.send(room_id)\n</code></pre>"},{"location":"websocket/#5-rediswebsocketconnectionbackend","title":"5. RedisWebSocketConnectionBackend","text":"<p>The Redis-based implementation of the WebSocketConnectionBackend:</p> <ul> <li>Uses Redis pub/sub channels for message distribution</li> <li>Enables cross-instance communication</li> <li>Handles message serialization and deserialization</li> </ul>"},{"location":"websocket/#6-websocketinterceptor","title":"6. WebSocketInterceptor","text":"<p>The interceptor that integrates everything with the Jararaca framework:</p> <ul> <li>Manages WebSocket lifecycle</li> <li>Provides a connection manager for WebSocket endpoints</li> <li>Registers WebSocket routes with FastAPI</li> </ul>"},{"location":"websocket/#message-flow","title":"Message Flow","text":"<p>When sending WebSocket messages in a distributed environment, the flow is as follows:</p> <pre><code>sequenceDiagram\n    participant C as Client\n    participant I1 as Instance 1\n    participant R as Redis\n    participant I2 as Instance 2\n\n    C-&gt;&gt;I1: Connect to WebSocket\n    I1-&gt;&gt;I1: Register connection\n    C-&gt;&gt;I1: Join room \"room1\"\n    I1-&gt;&gt;I1: Add to room \"room1\"\n\n    C-&gt;&gt;I1: Send message\n    I1-&gt;&gt;R: Publish to channel\n    R-&gt;&gt;I2: Deliver to subscribers\n    I2-&gt;&gt;C: Forward to clients in room\n</code></pre> <ol> <li>Message Creation: A <code>WebSocketMessage</code> is created and sent to specific rooms</li> <li>Local Delivery: The message is delivered to connections in those rooms on the current instance</li> <li>Redis Publication: The message is published to Redis channels</li> <li>Cross-Instance Distribution: Other instances receive the message from Redis</li> <li>Remote Delivery: Other instances deliver the message to their connected clients in the target rooms</li> </ol>"},{"location":"websocket/#using-the-websocket-system","title":"Using the WebSocket System","text":""},{"location":"websocket/#defining-websocket-messages","title":"Defining WebSocket Messages","text":"<p>Create custom message types by extending the <code>WebSocketMessage</code> class:</p> <pre><code>from jararaca import WebSocketMessage\n\nclass ChatMessage(WebSocketMessage):\n    MESSAGE_ID = \"chat.message\"\n\n    user_id: str\n    username: str\n    content: str\n    timestamp: str\n</code></pre>"},{"location":"websocket/#setting-up-the-websocket-interceptor","title":"Setting Up the WebSocket Interceptor","text":"<p>Configure the WebSocket interceptor in your Jararaca application:</p> <pre><code>from jararaca import (\n    Microservice,\n    WebSocketInterceptor,\n    RedisWebSocketConnectionBackend,\n)\nfrom redis.asyncio import Redis\n\napp = Microservice(\n    # ...other configuration...\n    interceptors=[\n        # ...other interceptors...\n        WebSocketInterceptor(\n            backend=RedisWebSocketConnectionBackend(\n                send_pubsub_channel=\"jararaca:websocket:send\",\n                broadcast_pubsub_channel=\"jararaca:websocket:broadcast\",\n                conn=Redis.from_url(\"redis://localhost\", decode_responses=False),\n            )\n        ),\n    ],\n)\n</code></pre>"},{"location":"websocket/#creating-websocket-endpoints","title":"Creating WebSocket Endpoints","text":"<p>Define WebSocket endpoints using the <code>@WebSocketEndpoint</code> decorator:</p> <pre><code>from jararaca import WebSocketEndpoint, RestController, use_ws_manager\nfrom fastapi import WebSocket, APIRouter\nfrom pydantic import BaseModel\n\n# Model for client-to-server REST communication\nclass ChatMessageRequest(BaseModel):\n    content: str\n\n@RestController(\"/chat\")\nclass ChatController:\n    def __init__(self):\n        self.router = APIRouter()\n\n    # REST endpoint for client-to-server communication\n    @self.router.post(\"/{room_id}/message\")\n    async def send_message(self, room_id: str, message: ChatMessageRequest):\n        # Process the message from client\n        # ...\n\n        # Create and send response via WebSocket to all clients in the room\n        ws_message = ChatMessage(\n            user_id=\"123\",\n            username=\"user1\",\n            content=message.content,\n            timestamp=\"2025-04-17T12:34:56Z\"\n        )\n\n        await ws_message.send(room_id)\n        return {\"status\": \"sent\"}\n\n    # WebSocket endpoint for server-to-client communication only\n    @WebSocketEndpoint(\"/ws/{room_id}\")\n    async def chat_endpoint(self, websocket: WebSocket, room_id: str):\n        await websocket.accept()\n\n        # Get the WebSocket manager\n        ws_manager = use_ws_manager()\n\n        # Add socket to room\n        await ws_manager.add_websocket(websocket)\n        await ws_manager.join([room_id], websocket)\n\n        try:\n            # Keep the connection alive\n            # Note: We don't process messages from the client via WebSocket\n            # Clients should use the REST endpoints for sending messages\n            while True:\n                # This only keeps the connection alive\n                # Any data received is ignored as client should use REST API\n                await websocket.receive()\n\n        except:\n            # Handle disconnection\n            await ws_manager.remove_websocket(websocket)\n</code></pre>"},{"location":"websocket/#client-implementation-example","title":"Client Implementation Example","text":"<p>Here's how a client might interact with the system:</p> <pre><code>// Client-side JavaScript\n\n// For sending messages TO the server (via REST API)\nasync function sendMessage(roomId, content) {\n  const response = await fetch(`/chat/${roomId}/message`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({ content })\n  });\n  return response.json();\n}\n\n// For receiving messages FROM the server (via WebSocket)\nconst socket = new WebSocket(`ws://your-server.com/ws/${roomId}`);\n\nsocket.onmessage = (event) =&gt; {\n  const message = JSON.parse(event.data);\n  // Handle incoming message from server\n  displayMessage(message);\n};\n\n// Usage example\ndocument.getElementById('send-button').addEventListener('click', () =&gt; {\n  const content = document.getElementById('message-input').value;\n  sendMessage(roomId, content);\n});\n</code></pre>"},{"location":"websocket/#broadcasting-messages","title":"Broadcasting Messages","text":"<p>To broadcast a message to all connected clients:</p> <pre><code># Create the message\nnotification = SystemNotification(\n    message=\"System maintenance in 5 minutes\",\n    severity=\"warning\",\n    timestamp=\"2025-04-17T12:30:00Z\"\n)\n\n# Broadcast as bytes\nws_manager = use_ws_manager()\nawait ws_manager.broadcast(\n    notification.model_dump_json().encode()\n)\n</code></pre>"},{"location":"websocket/#sending-to-specific-rooms","title":"Sending to Specific Rooms","text":"<p>To send a message to specific rooms:</p> <pre><code># Send directly with the message\nawait chat_message.send(\"room1\", \"room2\")\n\n# Or use the manager\nawait ws_manager.send([\"room1\", \"room2\"], chat_message)\n</code></pre>"},{"location":"websocket/#integration-with-message-bus","title":"Integration with Message Bus","text":"<p>One of Jararaca's powerful features is the ability to seamlessly integrate the WebSocket system with the message bus:</p> <pre><code>@MessageBusController()\nclass NotificationController:\n    @MessageHandler(UserActivityMessage)\n    async def handle_user_activity(self, message: MessageOf[UserActivityMessage]):\n        user_data = message.payload()\n\n        # Create a WebSocket message\n        notification = ActivityNotification(\n            user_id=user_data.user_id,\n            action=user_data.action,\n            timestamp=user_data.timestamp\n        )\n\n        # Send to user's room\n        await notification.send(f\"user-{user_data.user_id}\")\n</code></pre> <p>This allows background processes to send real-time updates to connected clients, enabling truly reactive applications.</p>"},{"location":"websocket/#under-the-hood-redis-implementation","title":"Under the Hood: Redis Implementation","text":"<p>The <code>RedisWebSocketConnectionBackend</code> uses Redis pub/sub channels to distribute messages across multiple Jararaca instances:</p> <ol> <li>Message Publishing:</li> <li>When sending to rooms, messages are published to the <code>send_pubsub_channel</code></li> <li>When broadcasting, messages are published to the <code>broadcast_pubsub_channel</code></li> <li> <p>Messages are serialized into a specific format for transmission</p> </li> <li> <p>Message Consumption:</p> </li> <li>Each instance subscribes to both channels</li> <li>When messages arrive, they're decoded and forwarded to the appropriate WebSocket connections</li> <li> <p>Background tasks handle message consumption and delivery</p> </li> <li> <p>Room Management:</p> </li> <li>Each instance maintains its own registry of rooms and connections</li> <li>Messages for specific rooms are only delivered to instances with connections in those rooms</li> </ol>"},{"location":"websocket/#best-practices","title":"Best Practices","text":"<ol> <li>Message Structure: Keep WebSocket messages focused and well-structured</li> <li>Room Naming: Use consistent naming conventions for rooms (e.g., <code>user-{user_id}</code>, <code>chat-{chat_id}</code>)</li> <li>Error Handling: Always handle WebSocket disconnections properly</li> <li>Message Validation: Leverage Pydantic's validation to ensure message integrity</li> <li>Scaling: Monitor Redis performance when scaling to many instances or high message volumes</li> </ol>"},{"location":"websocket/#conclusion","title":"Conclusion","text":"<p>Jararaca's distributed WebSocket system provides a powerful way to add real-time communication capabilities to your applications. By combining WebSockets with the message bus system, you can build truly reactive applications where events from any part of your system can trigger real-time updates to connected clients.</p>"}]}