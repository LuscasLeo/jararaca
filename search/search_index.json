{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Jararaca Microservice Framework","text":"<p>Jararaca is a powerful Python microservice framework that provides a comprehensive set of tools and abstractions for building robust microservice architectures. It integrates seamlessly with FastAPI, SQLAlchemy, Redis, and RabbitMQ to deliver a complete solution for modern microservice development.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>\ud83d\ude80 FastAPI Integration: Built-in support for FastAPI with automatic OpenAPI documentation</li> <li>\ud83c\udf10 HTTP RPC Client: Complete REST client implementation with decorators, authentication, caching, and retry logic</li> <li>\ud83d\udd0c WebSocket Support: Real-time communication capabilities with Redis-backed WebSocket management</li> <li>\ud83d\udce6 Dependency Injection: Flexible dependency injection system with interceptors</li> <li>\ud83d\udcca Database Integration: SQLAlchemy integration with async support</li> <li>\ud83d\udce1 Message Bus: RabbitMQ integration for event-driven architecture</li> <li>\u26a1 Retry Mechanism: Robust retry system with exponential backoff for resilient operations</li> <li>\ud83d\udd0d Query Operations: Advanced query capabilities with pagination and filtering</li> <li>\u23f1\ufe0f Scheduled Tasks: Distributed cron-based task scheduling with message broker integration</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install jararaca\n</code></pre>"},{"location":"#cli-commands","title":"CLI Commands","text":"<p>Jararaca comes with a powerful command-line interface to help you manage your microservices:</p>"},{"location":"#worker-message-bus-worker","title":"<code>worker</code> - Message Bus Worker","text":"<pre><code>jararaca worker APP_PATH [OPTIONS]\n</code></pre> <p>Starts a message bus worker that processes asynchronous messages from a message queue.</p> <p>Options:</p> <ul> <li><code>--broker-url</code>: The URL for the message broker (required) [env: BROKER_URL]</li> <li><code>--backend-url</code>: The URL for the message broker backend (required) [env: BACKEND_URL]</li> <li><code>--handlers</code>: Comma-separated list of handler names to listen to (optional) [env: HANDLERS]</li> <li><code>--reload</code>: Enable auto-reload when Python files change (for development) [env: RELOAD]</li> <li><code>--src-dir</code>: The source directory to watch for changes when --reload is enabled (default: \"src\") [env: SRC_DIR]</li> </ul> <p>Environment Variables: - <code>APP_PATH</code>: The application module path - All options support environment variables as indicated above</p> <p>Example with environment variables: <pre><code>export APP_PATH=\"app.module:app\"\nexport BROKER_URL=\"amqp://guest:guest@localhost:5672/?exchange=jararaca&amp;prefetch_count=1\"\nexport BACKEND_URL=\"redis://localhost:6379\"\nexport HANDLERS=\"send_email,process_payment\"\nexport RELOAD=\"true\"\njararaca worker\n</code></pre> - <code>--reload</code>: Enable auto-reload when Python files change (for development) - <code>--src-dir</code>: The source directory to watch for changes when --reload is enabled (default: \"src\")</p>"},{"location":"#server-http-server","title":"<code>server</code> - HTTP Server","text":"<pre><code>jararaca server APP_PATH [OPTIONS]\n</code></pre> <p>Starts a FastAPI HTTP server for your microservice.</p> <p>Options:</p> <ul> <li><code>--host</code>: Host to bind the server (default: \"0.0.0.0\") [env: HOST]</li> <li><code>--port</code>: Port to bind the server (default: 8000) [env: PORT]</li> </ul> <p>Environment Variables: - <code>APP_PATH</code>: The application module path - <code>HOST</code>: Host to bind the server - <code>PORT</code>: Port to bind the server</p> <p>Example with environment variables: <pre><code>export APP_PATH=\"app.module:app\"\nexport HOST=\"127.0.0.1\"\nexport PORT=\"8080\"\njararaca server\n</code></pre></p>"},{"location":"#alternative-using-uvicorn-directly","title":"Alternative: Using <code>uvicorn</code> directly","text":"<p>For production environments, you can create an ASGI application and run it with uvicorn:</p> <pre><code>from fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom fastapi.types import Lifespan\n\nfrom jararaca.presentation.http_microservice import HttpMicroservice\nfrom jararaca.presentation.server import create_http_server\n\n\ndef fastapi_factory(lifespan: Lifespan[FastAPI]) -&gt; FastAPI:\n    app = FastAPI(\n        lifespan=lifespan,\n    )\n\n    app.router.prefix = \"/api\"\n\n    app.add_middleware(\n        CORSMiddleware,\n        allow_origins=[\"*\"],\n        allow_credentials=True,\n        allow_methods=[\"*\"],\n        allow_headers=[\"*\"],\n        expose_headers=[\"error\", \"reason\", \"scope\"],\n    )\n\n    return app\n\n\nhttp_app = HttpMicroservice(app, fastapi_factory)\n\nasgi_app = create_http_server(http_app)\n</code></pre> <p>Then run the server with:</p> <pre><code>uvicorn app_module:asgi_app\n</code></pre>"},{"location":"#beat-task-scheduler","title":"<code>beat</code> - Task Scheduler","text":"<pre><code>jararaca beat APP_PATH [OPTIONS]\n</code></pre> <p>Runs scheduled tasks defined in your application using cron expressions.</p> <p>Options:</p> <ul> <li><code>--interval</code>: Polling interval in seconds (default: 1) [env: INTERVAL]</li> <li><code>--broker-url</code>: The URL for the message broker (required) [env: BROKER_URL]</li> <li><code>--backend-url</code>: The URL for the message broker backend (required) [env: BACKEND_URL]</li> <li><code>--actions</code>: Comma-separated list of action names to run (optional) [env: ACTIONS]</li> <li><code>--reload</code>: Enable auto-reload when Python files change (for development) [env: RELOAD]</li> <li><code>--src-dir</code>: The source directory to watch for changes when --reload is enabled (default: \"src\") [env: SRC_DIR]</li> </ul> <p>Environment Variables: - <code>APP_PATH</code>: The application module path - All options support environment variables as indicated above</p> <p>Example with environment variables: <pre><code>export APP_PATH=\"app.module:app\"\nexport INTERVAL=\"5\"\nexport BROKER_URL=\"amqp://guest:guest@localhost:5672/?exchange=jararaca&amp;prefetch_count=1\"\nexport BACKEND_URL=\"redis://localhost:6379\"\nexport ACTIONS=\"send_emails,process_payments\"\nexport RELOAD=\"true\"\njararaca beat\n</code></pre></p> <pre><code>jararaca scheduler_v2 APP_PATH [OPTIONS]\n</code></pre> <p>Runs an enhanced version of the task scheduler with support for message broker backend integration.</p> <p>Options:</p> <ul> <li><code>--interval</code>: Polling interval in seconds (default: 1, required)</li> <li><code>--broker-url</code>: The URL for the message broker (required)</li> <li><code>--backend-url</code>: The URL for the message broker backend (required)</li> </ul>"},{"location":"#gen-tsi-generate-typescript-interfaces","title":"<code>gen-tsi</code> - Generate TypeScript Interfaces","text":"<pre><code>jararaca gen-tsi APP_PATH FILE_PATH [OPTIONS]\n</code></pre> <p>Generates TypeScript interfaces from your Python models to ensure type safety between your frontend and backend.</p> <p>Options:</p> <ul> <li><code>--watch</code>: Watch for file changes and regenerate TypeScript interfaces automatically [env: WATCH]</li> <li><code>--src-dir</code>: Source directory to watch for changes (default: \"src\") [env: SRC_DIR]</li> <li><code>--stdout</code>: Print generated interfaces to stdout instead of writing to a file [env: STDOUT]</li> <li><code>--post-process</code>: Command to run after generating the interfaces, {file} will be replaced with the output file path [env: POST_PROCESS]</li> </ul> <p>Environment Variables: - <code>APP_PATH</code>: The application module path - All options support environment variables as indicated above</p> <p>Example with watch mode:</p> <pre><code>jararaca gen-tsi app.module:app interfaces.ts --watch\n</code></pre> <p>This will generate the TypeScript interfaces initially and then watch for any changes to Python files in the src directory, automatically regenerating the interfaces when changes are detected. You can stop watching with Ctrl+C.</p> <p>Example with environment variables: <pre><code>export APP_PATH=\"app.module:app\"\nexport FILE_PATH=\"interfaces.ts\"\nexport WATCH=\"true\"\nexport SRC_DIR=\"src\"\njararaca gen-tsi\n</code></pre></p> <p>Note: To use the watch feature, you need to install the watchdog package:</p> <pre><code>pip install jararaca[watch]\n</code></pre> <p>Or directly:</p> <pre><code>pip install watchdog\n</code></pre>"},{"location":"#gen-entity-generate-entity-template","title":"<code>gen-entity</code> - Generate Entity Template","text":"<pre><code>jararaca gen-entity ENTITY_NAME FILE_PATH\n</code></pre> <p>Generates a new entity file template with proper naming conventions in different formats (snake_case, PascalCase, kebab-case).</p> <p>Environment Variables: - <code>ENTITY_NAME</code>: The name of the entity to generate - <code>FILE_PATH</code>: The path where the entity file should be created</p> <p>Example:</p> <pre><code># Using command line arguments\njararaca gen-entity User user.py\n\n# Using environment variables\nexport ENTITY_NAME=\"User\"\nexport FILE_PATH=\"user.py\"\njararaca gen-entity\n</code></pre>"},{"location":"#declare-declare-message-infrastructure","title":"<code>declare</code> - Declare Message Infrastructure","text":"<pre><code>jararaca declare APP_PATH [OPTIONS]\n</code></pre> <p>Declares RabbitMQ infrastructure (exchanges and queues) for message handlers and schedulers without starting the actual consumption processes.</p> <p>Options: - <code>--broker-url</code>: Broker URL (e.g., amqp://guest:guest@localhost/) [env: BROKER_URL] - <code>-i, --interactive-mode</code>: Enable interactive mode for queue declaration [env: INTERACTIVE_MODE] - <code>-f, --force</code>: Force recreation by deleting existing exchanges and queues [env: FORCE]</p> <p>Environment Variables: - <code>APP_PATH</code>: The application module path - <code>BROKER_URL</code>: The broker URL - <code>INTERACTIVE_MODE</code>: Enable interactive mode - <code>FORCE</code>: Force recreation of infrastructure</p> <p>Examples:</p> <pre><code># Declare infrastructure\njararaca declare myapp:app --broker-url amqp://guest:guest@localhost/\n\n# Force recreation of queues and exchanges\njararaca declare myapp:app --broker-url amqp://guest:guest@localhost/ --force\n\n# Using environment variables\nexport APP_PATH=\"myapp:app\"\nexport BROKER_URL=\"amqp://guest:guest@localhost/\"\nexport FORCE=\"true\"\njararaca declare\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Here's a basic example of how to create a microservice with Jararaca:</p> <pre><code>from app.app_config import AppConfig, AppFactoryWithAppConfig\nfrom app.auth.auth_controller import (\n    AuthConfig,\n    AuthController,\n    InMemoryTokenBlackListService,\n    TokenBlackListService,\n)\nfrom app.extraction.models_controller import ExtractionModelController\nfrom app.extraction.secrets_controller import SecretsController\nfrom app.extraction.tasks_controller import TasksController\nfrom app.providers import REDIS_TOKEN\nfrom redis.asyncio import Redis\n\nfrom jararaca import (\n    AIOPikaConnectionFactory,\n    AIOSQAConfig,\n    AIOSqlAlchemySessionInterceptor,\n    AppConfigurationInterceptor,\n    HttpMicroservice,\n    MessageBusPublisherInterceptor,\n    Microservice,\n    ProviderSpec,\n    RedisWebSocketConnectionBackend,\n    Token,\n    WebSocketInterceptor,\n    create_http_server,\n)\n\n# Create your microservice instance\napp = Microservice(\n    providers=[\n        # Redis provider for caching and WebSocket management\n        ProviderSpec(\n            provide=REDIS_TOKEN,\n            use_factory=AppFactoryWithAppConfig(\n                lambda config: Redis.from_url(config.REDIS_URL, decode_responses=False)\n            ),\n            after_interceptors=True,\n        ),\n        # Authentication configuration\n        ProviderSpec(\n            provide=Token(AuthConfig, \"AUTH_CONFIG\"),\n            use_value=AuthConfig(\n                secret=\"your-secret-key\",\n                identity_refresh_token_expires_delta_seconds=60 * 60 * 24 * 30,\n                identity_token_expires_delta_seconds=60 * 60,\n            ),\n        ),\n        # Token blacklist service for JWT management\n        ProviderSpec(\n            provide=TokenBlackListService,\n            use_value=InMemoryTokenBlackListService(),\n        ),\n    ],\n    controllers=[\n        TasksController,  # Your application controllers\n    ],\n    interceptors=[\n        # Application configuration interceptor\n        AppConfigurationInterceptor(\n            global_configs=[\n                (Token(AppConfig, \"APP_CONFIG\"), AppConfig),\n            ]\n        ),\n        # Message bus interceptor for RabbitMQ\n        AppFactoryWithAppConfig(\n            lambda config: MessageBusPublisherInterceptor(\n                connection_factory=AIOPikaConnectionFactory(\n                    url=config.AMQP_URL,\n                    exchange=\"jararaca_ex\",\n                ),\n            )\n        ),\n        # Database session interceptor\n        AppFactoryWithAppConfig(\n            lambda config: AIOSqlAlchemySessionInterceptor(\n                AIOSQAConfig(\n                    connection_name=\"default\",\n                    url=config.DATABASE_URL,\n                )\n            )\n        ),\n        # WebSocket interceptor\n        AppFactoryWithAppConfig(\n            lambda config: WebSocketInterceptor(\n                backend=RedisWebSocketConnectionBackend(\n                    send_pubsub_channel=\"jararaca:websocket:send\",\n                    broadcast_pubsub_channel=\"jararaca:websocket:broadcast\",\n                    conn=Redis.from_url(config.REDIS_URL, decode_responses=False),\n                )\n            ),\n        ),\n    ],\n)\n\n# Create FastAPI application\nhttp_app = create_http_server(\n    HttpMicroservice(\n        app=app,\n        factory=fastapi_factory,\n    )\n)\n</code></pre>"},{"location":"#core-concepts","title":"Core Concepts","text":""},{"location":"#controllers","title":"Controllers","text":"<p>Controllers are the heart of your microservice. They handle HTTP requests, WebSocket connections, and message bus events. Here's an example of a task controller:</p> <pre><code>@MessageBusController()\n@RestController(\"/tasks\")\nclass TasksController:\n    @Post(\"/\")\n    async def create_task(self, task: CreateTaskSchema) -&gt; Identifiable[TaskSchema]:\n        # Your implementation here\n        pass\n\n    @Get(\"/\")\n    async def get_tasks(self) -&gt; List[TaskSchema]:\n        # Your implementation here\n        pass\n</code></pre>"},{"location":"#entities","title":"Entities","text":"<p>Entities represent your database models. They can be automatically mapped to and from Pydantic models:</p> <pre><code>class TaskEntity(IdentifiableEntity, DatedEntity):\n    __tablename__ = \"tasks\"\n\n    status: Mapped[Literal[\"PENDING\", \"RUNNING\", \"FINISHED\", \"ERROR\"]]\n    extraction_model_id: Mapped[UUID]\n    # ... other fields\n</code></pre>"},{"location":"#query-operations","title":"Query Operations","text":"<p>Jararaca provides powerful query operations with support for pagination and filtering:</p> <pre><code>class TaskSimpleFilter(PaginatedFilter, DateOrderedFilter):\n    pass\n\n@Get(\"/\")\nasync def get_tasks(self, filter: TaskSimpleFilter) -&gt; Paginated[TaskSchema]:\n    return await self.tasks_query_operations.query(filter)\n</code></pre>"},{"location":"#messaging-and-real-time-communication","title":"Messaging and Real-Time Communication","text":"<p>Jararaca provides powerful abstractions for both asynchronous messaging (via message bus) and real-time communication (via WebSockets).</p>"},{"location":"#message-bus-communication","title":"Message Bus Communication","text":"<p>The <code>Message</code> class is the foundation for all message bus communication in Jararaca. Messages can be tasks or events that flow through your microservice architecture.</p> <pre><code>from pydantic import Field\n\nfrom jararaca import Message\n\n\nclass UserCreatedMessage(Message):\n    MESSAGE_TOPIC = \"user.created\"\n    MESSAGE_TYPE = \"event\"  # or \"task\"\n\n    user_id: str\n    username: str\n    email: str\n</code></pre>"},{"location":"#publishing-messages","title":"Publishing Messages","text":"<p>You can publish messages in two ways:</p> <ol> <li>Using the message's built-in <code>publish()</code> method:</li> </ol> <pre><code>user_message = UserCreatedMessage(\n    user_id=\"123\",\n    username=\"johndoe\",\n    email=\"john@example.com\"\n)\nawait user_message.publish()  # Uses the MESSAGE_TOPIC defined in the class\n</code></pre> <ol> <li>Using the publisher directly:</li> </ol> <pre><code>from jararaca import use_publisher\n\npublisher = use_publisher()\nawait publisher.publish(user_message, \"custom.topic\")  # Override the default topic\n</code></pre>"},{"location":"#consuming-messages","title":"Consuming Messages","text":"<p>To consume messages, create a handler with the <code>@MessageHandler</code> decorator:</p> <pre><code>from jararaca import Message, MessageBusController, MessageHandler\n\n@MessageBusController()\nclass UserEventsController:\n    @MessageHandler(\"user.created\")\n    async def handle_user_created(self, message: MessageOf[UserCreatedMessage]):\n        user_data = message.payload()\n        # Process the message\n        print(f\"User created: {user_data.username}\")\n</code></pre>"},{"location":"#websocket-communication","title":"WebSocket Communication","text":"<p>The <code>WebSocketMessage</code> class enables real-time communication with connected WebSocket clients. It provides a simple way to send messages to specific rooms or broadcast to all clients.</p> <pre><code>from jararaca import WebSocketMessage\nfrom pydantic import Field\n\nclass ChatMessage(WebSocketMessage):\n    MESSAGE_ID = \"chat.message\"\n\n    user_id: str\n    username: str\n    content: str\n    timestamp: str\n</code></pre>"},{"location":"#sending-websocket-messages","title":"Sending WebSocket Messages","text":"<p>You can send WebSocket messages to specific rooms:</p> <pre><code>message = ChatMessage(\n    user_id=\"123\",\n    username=\"johndoe\",\n    content=\"Hello, world!\",\n    timestamp=\"2025-04-17T12:00:00Z\"\n)\n\n# Send to specific rooms\nawait message.send(\"room1\", \"room2\")\n</code></pre>"},{"location":"#manual-websocket-management","title":"Manual WebSocket Management","text":"<p>For more control, you can use the WebSocket manager directly:</p> <pre><code>from jararaca import use_ws_manager\n\n# Get the WebSocket manager\nws_manager = use_ws_manager()\n\n# Add a WebSocket connection to rooms\nawait ws_manager.add_websocket_to_room(websocket, \"room1\")\n\n# Send a message to specific rooms\nawait ws_manager.send([\"room1\", \"room2\"], message)\n\n# Broadcast to all connections\nawait ws_manager.broadcast(message)\n</code></pre>"},{"location":"#websocket-endpoint","title":"WebSocket Endpoint","text":"<p>Create a WebSocket endpoint using the <code>@WebSocketEndpoint</code> decorator:</p> <pre><code>from jararaca import WebSocketEndpoint, RestController\nfrom fastapi import WebSocket\n\n@RestController(\"/ws\")\n@RegisterWebSocketMessage(ChatMessage) # Register the WebSocket message in order to be generated in the ts files\nclass WebSocketController:\n    @WebSocketEndpoint(\"/chat/{room_id}\")\n    async def chat_endpoint(self, websocket: WebSocket, room_id: str):\n        await websocket.accept()\n\n        # Add to room\n        ws_manager = use_ws_manager()\n        await ws_manager.add_websocket_to_room(websocket, room_id)\n\n        try:\n            while True:\n                data = await websocket.receive_text()\n                message = ChatMessage(\n                    user_id=\"123\",\n                    username=\"johndoe\",\n                    content=data,\n                    timestamp=\"2025-04-17T12:00:00Z\"\n                )\n                await message.send(room_id)\n        except:\n            # Remove from room when connection closes\n            await ws_manager.remove_websocket_from_room(websocket, room_id)\n</code></pre>"},{"location":"#integration-between-message-bus-and-websockets","title":"Integration Between Message Bus and WebSockets","text":"<p>One of Jararaca's strengths is the ability to seamlessly integrate message bus events with WebSocket communication, enabling real-time updates from background processes:</p> <pre><code>@MessageBusController()\n@RestController(\"/notifications\")\nclass NotificationController:\n    @MessageHandler(\"user.activity\")\n    async def handle_user_activity(self, message: MessageOf[UserActivityMessage]):\n        user_data = message.payload()\n\n        # Create a WebSocket message\n        notification = ActivityNotification(\n            user_id=user_data.user_id,\n            action=user_data.action,\n            timestamp=user_data.timestamp\n        )\n\n        # Send to user's room\n        await notification.send(f\"user-{user_data.user_id}\")\n</code></pre> <p>This allows you to build truly reactive systems where events processed in background workers can immediately update connected clients through WebSockets.</p>"},{"location":"#advanced-features","title":"Advanced Features","text":""},{"location":"#websocket-support","title":"WebSocket Support","text":"<p>Real-time communication is built-in:</p> <pre><code>@WebSocketEndpoint(\"/ws\")\nasync def ws_endpoint(self, websocket: WebSocket):\n    await websocket.accept()\n    await use_ws_manager().add_websocket(websocket)\n    # Handle WebSocket messages\n</code></pre>"},{"location":"#scheduled-tasks","title":"Scheduled Tasks","text":"<p>Run periodic tasks using cron expressions:</p> <pre><code>@ScheduledAction(\"* * * * * */5\")\nasync def scheduled_task(self):\n    # Your scheduled task implementation\n    pass\n</code></pre>"},{"location":"#message-bus-integration","title":"Message Bus Integration","text":"<p>Publish and consume messages through RabbitMQ:</p> <pre><code>@MessageHandler(TaskSchema)\nasync def process_task(self, message: MessageOf[TaskSchema]):\n    # Process incoming messages\n    pass\n</code></pre>"},{"location":"#configuration","title":"Configuration","text":"<p>Configure your microservice through environment variables or configuration files:</p> <pre><code>class AppConfig(BaseModel):\n    DATABASE_URL: str\n    REDIS_URL: str\n    AMQP_URL: str\n</code></pre>"},{"location":"#best-practices","title":"Best Practices","text":"<ol> <li>Use Dependency Injection: Leverage the DI system for better testability and maintainability</li> <li>Implement Proper Error Handling: Use HTTP exceptions for API errors</li> <li>Use Type Hints: Take advantage of Python's type system for better code quality</li> <li>Follow RESTful Principles: Design your API endpoints following REST conventions</li> </ol>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome! Please feel free to submit a Pull Request.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details.</p>"},{"location":"architecture/","title":"Jararaca Architecture","text":""},{"location":"architecture/#core-concept-unified-runtime-interface","title":"Core Concept: Unified Runtime Interface","text":"<p>Jararaca implements a unified runtime interface that allows different types of applications (REST API, Message Bus Worker, and Scheduler) to share the same utilities and context. This means that utilities like <code>@use_session</code> can be used consistently across different runtime contexts, even though they run as separate processes.</p>"},{"location":"architecture/#runtime-types","title":"Runtime Types","text":"<ol> <li> <p>REST API Runtime</p> </li> <li> <p>Handles HTTP requests and WebSocket connections</p> </li> <li>Executes REST controllers</li> <li> <p>Uses <code>@RestController</code> decorator for route definitions</p> </li> <li> <p>Message Bus Worker Runtime</p> </li> <li> <p>Processes asynchronous messages and events</p> </li> <li>Handles tasks and events through <code>@MessageBusController</code></li> <li> <p>Manages message queues and event processing</p> </li> <li> <p>Scheduler Runtime</p> </li> <li>Executes scheduled tasks at specified intervals</li> <li>Uses <code>@ScheduledAction</code> decorator for task definitions</li> <li>Manages cron-based job execution</li> </ol>"},{"location":"architecture/#application-structure","title":"Application Structure","text":"<p>The application structure follows a hierarchical pattern:</p> <ol> <li> <p>Microservice Declaration</p> </li> <li> <p>Uses <code>@Microservice</code> class for configuration</p> </li> <li>Declares providers, controllers, and interceptors</li> <li>No execution happens at declaration time</li> <li> <p>Configuration is shared across all runtimes</p> </li> <li> <p>Application Implementation</p> </li> <li> <p>REST Controllers (<code>@RestController</code>)</p> <ul> <li>Handle HTTP endpoints</li> <li>Run in REST API runtime</li> <li>Support middleware and dependency injection</li> </ul> </li> <li> <p>Events and Tasks (<code>@MessageBusController</code>)</p> <ul> <li>Handle asynchronous operations</li> <li>Run in Message Bus Worker runtime</li> <li>Support message publishing and consumption</li> </ul> </li> <li> <p>Scheduled Jobs (<code>@ScheduledAction</code>)</p> <ul> <li>Execute at specified intervals</li> <li>Run in Scheduler runtime</li> <li>Support cron-based scheduling</li> </ul> </li> </ol>"},{"location":"architecture/#architecture-diagram","title":"Architecture Diagram","text":"<pre><code>graph LR\n    subgraph \"Runtime Layer\"\n        REST[REST API Runtime]\n        Worker[Message Bus Worker Runtime]\n        Scheduler[Scheduler Runtime]\n    end\n\n    subgraph \"Application Layer\"\n        Microservice[Microservice Declaration]\n        RESTController[REST Controllers]\n        MessageBus[Events &amp; Tasks]\n        ScheduledJobs[Scheduled Jobs]\n    end\n\n    subgraph \"Shared Utilities\"\n        Session[use_session]\n        Publisher[use_publisher]\n        WS[use_ws_manager]\n    end\n\n    Microservice --&gt; REST\n    Microservice --&gt; Worker\n    Microservice --&gt; Scheduler\n\n    REST --&gt; RESTController\n    Worker --&gt; MessageBus\n    Scheduler --&gt; ScheduledJobs\n\n    RESTController --&gt; Session\n    MessageBus --&gt; Session\n    ScheduledJobs --&gt; Session\n\n    RESTController --&gt; Publisher\n    MessageBus --&gt; Publisher\n    ScheduledJobs --&gt; Publisher\n\n    RESTController --&gt; WS\n    MessageBus --&gt; WS\n    ScheduledJobs --&gt; WS\n</code></pre>"},{"location":"architecture/#key-features","title":"Key Features","text":"<ol> <li> <p>Shared Context</p> </li> <li> <p>All runtimes share the same context and utilities</p> </li> <li>Consistent access to services like database sessions</li> <li> <p>Unified dependency injection system</p> </li> <li> <p>Declarative Configuration</p> </li> <li> <p>Configuration is defined once in <code>Microservice</code></p> </li> <li>Runtime-specific settings are handled separately</li> <li> <p>Easy to maintain and modify</p> </li> <li> <p>Process Isolation</p> </li> <li> <p>Each runtime runs as a separate process</p> </li> <li>Clear separation of concerns</li> <li> <p>Independent scaling and deployment</p> </li> <li> <p>Unified Utilities</p> </li> <li>Common utilities like <code>@use_session</code> work across all runtimes</li> <li>Consistent API for database access, message publishing, etc.</li> <li>Reduced code duplication</li> </ol>"},{"location":"architecture/#usage-example","title":"Usage Example","text":"<pre><code>from jararaca import (\n    AIOPikaConnectionFactory,\n    AIOSQAConfig,\n    AIOSqlAlchemySessionInterceptor,\n    AppConfigurationInterceptor,\n    HttpMicroservice,\n    MessageBusPublisherInterceptor,\n    Microservice,\n    ProviderSpec,\n    RedisWebSocketConnectionBackend,\n    Token,\n    WebSocketInterceptor,\n    create_http_server,\n)\n\n\n# Define your application configuration\nclass AppConfig:\n    DATABASE_URL: str\n    REDIS_URL: str\n    AMQP_URL: str\n\n# Create the microservice with all necessary components\napp = Microservice(\n    providers=[\n        ProviderSpec(\n            provide=Token(Redis, \"REDIS\"),\n            use_factory=lambda config: Redis.from_url(config.REDIS_URL, decode_responses=False),\n            after_interceptors=True,\n        ),\n    ],\n    controllers=[\n        TasksController,  # Your controller class\n    ],\n    interceptors=[\n        # Configuration interceptor\n        AppConfigurationInterceptor(\n            global_configs=[\n                (Token(AppConfig, \"APP_CONFIG\"), AppConfig),\n            ]\n        ),\n        # Message bus interceptor\n        AppFactoryWithAppConfig(\n            lambda config: MessageBusPublisherInterceptor(\n                connection_factory=AIOPikaConnectionFactory(\n                    url=config.AMQP_URL,\n                    exchange=\"jararaca_ex\",\n                ),\n            )\n        ),\n        # Database session interceptor\n        AppFactoryWithAppConfig(\n            lambda config: AIOSqlAlchemySessionInterceptor(\n                AIOSQAConfig(\n                    connection_name=\"default\",\n                    url=config.DATABASE_URL,\n                )\n            )\n        ),\n        # WebSocket interceptor\n        AppFactoryWithAppConfig(\n            lambda config: WebSocketInterceptor(\n                backend=RedisWebSocketConnectionBackend(\n                    send_pubsub_channel=\"jararaca:websocket:send\",\n                    broadcast_pubsub_channel=\"jararaca:websocket:broadcast\",\n                    conn=Redis.from_url(config.REDIS_URL, decode_responses=False),\n                )\n            ),\n        ),\n    ],\n)\n\n# Create HTTP server for REST API runtime\nhttp_app = create_http_server(\n    HttpMicroservice(\n        app=app,\n        factory=fastapi_factory,\n    )\n)\n\n\nclass HelloTask(Message):\n    MESSAGE_TYPE = \"task\"\n    MESSAGE_TOPIC = \"task.topic.name\"\n\n    message: str\n\n# Example controller showing unified utilities across runtimes\n@MessageBusController()\n@RestController(\"/tasks\")\nclass TasksController:\n    def __init__(self, redis: Annotated[Redis, Token(Redis, \"REDIS\")]):\n        self.redis = redis\n        self.tasks_crud = CRUDOperations(TaskEntity, use_session)\n\n    @Post(\"/\")\n    async def create_task(self, task: CreateTaskSchema) -&gt; Identifiable[TaskSchema]:\n        # Use session in REST context\n        task_entity = await self.tasks_crud.create(task)\n        await use_ws_manager().broadcast(b\"New Task Created\")\n        await use_publisher().publish(task_entity.to_identifiable(TaskSchema), topic=\"task\")\n        return task_entity.to_identifiable(TaskSchema)\n\n    @MessageHandler(HelloTask)\n    async def process_task(self, message: MessageOf[HelloTask]) -&gt; None:\n        # Use session in Message Bus context\n        print(message.message)\n\n    @ScheduledAction(\"* * * * * */5\")\n    async def scheduled_task(self) -&gt; None:\n        # Use session in Scheduler context\n        pending_tasks = await use_session().execute(select(TaskEntity))\n        for task in pending_tasks:\n            await use_publisher().publish(task.to_identifiable(TaskSchema), topic=\"task\")\n</code></pre>"},{"location":"architecture/#context-hooks-and-interceptors","title":"Context Hooks and Interceptors","text":"<p>Jararaca provides a powerful system of context hooks (like <code>use_session</code>, <code>use_publisher</code>, <code>use_ws_manager</code>) that are managed through Python's <code>ContextVar</code> system. These hooks are configured separately for each execution context and are provided by interceptors configured in the <code>Microservice</code> instance.</p> <p>Important Note on Interceptor Order The order of interceptors in the <code>Microservice</code> instance matters significantly. Interceptors are executed in the order they are defined, meaning:</p> <ul> <li>The first interceptor in the list will set up its context before the subsequent ones</li> <li>This order affects how dependencies between different context hooks are resolved</li> <li>For example, if a database session is needed by a message publisher, the session interceptor should be configured before the publisher interceptor</li> </ul>"},{"location":"architecture/#how-context-hooks-work","title":"How Context Hooks Work","text":"<ol> <li> <p>Context Isolation</p> </li> <li> <p>Each execution (HTTP request, message processing, scheduled job) gets its own isolated context</p> </li> <li>Context hooks provide access to resources specific to that execution</li> <li> <p>Resources are automatically cleaned up when the execution completes</p> </li> <li> <p>Interceptor-Based Provision</p> </li> <li>Interceptors are responsible for setting up and managing the context</li> <li>They are configured in the <code>Microservice</code> instance</li> <li>Each interceptor handles a specific type of resource</li> </ol>"},{"location":"architecture/#example-database-session-management","title":"Example: Database Session Management","text":"<pre><code># The AIOSqlAlchemySessionInterceptor manages database sessions\nclass AIOSqlAlchemySessionInterceptor(AppInterceptor):\n    def __init__(self, config: AIOSQAConfig):\n        self.config = config\n        self.engine = create_async_engine(self.config.url)\n        self.sessionmaker = async_sessionmaker(self.engine)\n\n    @asynccontextmanager\n    async def intercept(self, app_context: AppContext) -&gt; AsyncGenerator[None, None]:\n        # Creates a new session for this execution\n        async with self.sessionmaker() as session:\n            # Provides the session to the context\n            with provide_session(self.config.connection_name, session):\n                try:\n                    yield\n                    await session.commit()\n                except Exception as e:\n                    await session.rollback()\n                    raise e\n</code></pre>"},{"location":"architecture/#context-hook-lifecycle","title":"Context Hook Lifecycle","text":"<ol> <li>Configuration</li> </ol> <pre><code>app = Microservice(\n    interceptors=[\n        AIOSqlAlchemySessionInterceptor(\n            AIOSQAConfig(\n                connection_name=\"default\",\n                url=config.DATABASE_URL,\n            )\n        ),\n        # Other interceptors...\n    ]\n)\n</code></pre> <ol> <li> <p>Execution</p> </li> <li> <p>When a request/message/job starts, interceptors are activated</p> </li> <li>Each interceptor sets up its context using <code>ContextVar</code></li> <li> <p>The context is available throughout the execution</p> </li> <li> <p>Cleanup</p> </li> <li>When execution completes, interceptors clean up resources</li> <li>Context is automatically reset</li> <li>Resources are properly closed/released</li> </ol>"},{"location":"architecture/#available-context-hooks","title":"Available Context Hooks","text":"<ol> <li> <p>Database Sessions (<code>use_session</code>)</p> </li> <li> <p>Provided by <code>AIOSqlAlchemySessionInterceptor</code></p> </li> <li>Creates isolated database sessions per execution</li> <li> <p>Handles transaction management automatically</p> </li> <li> <p>Message Publishing (<code>use_publisher</code>)</p> </li> <li> <p>Provided by <code>MessageBusPublisherInterceptor</code></p> </li> <li>Manages message publishing context</li> <li> <p>Ensures proper message delivery</p> </li> <li> <p>WebSocket Management (<code>use_ws_manager</code>)</p> </li> <li>Provided by <code>WebSocketInterceptor</code></li> <li>Handles WebSocket connections and broadcasting</li> <li>Manages connection state</li> </ol>"},{"location":"architecture/#usage-in-different-contexts","title":"Usage in Different Contexts","text":"<pre><code># In a REST Controller\n@RestController(\"/tasks\")\n@MessageBusController()\nclass TasksController:\n    @Get(\"/\")\n    async def get_tasks(self):\n        # Gets a session specific to this HTTP request\n        session = use_session()\n        return await session.execute(select(TaskEntity))\n\n\n    @MessageHandler(SomeTask)\n    async def process_task(self, message: MessageOf[SomeTask]):\n        # Gets a session specific to this message processing\n        session = use_session()\n\n    # In a Scheduled Job\n    @ScheduledAction(\"* * * * *\")\n    async def scheduled_task(self):\n        # Gets a session specific to this job execution\n        session = use_session()\n        await session.execute(select(TaskEntity))\n</code></pre> <p>This system ensures that:</p> <ul> <li>Each execution has its own isolated resources</li> <li>Resources are properly managed and cleaned up</li> <li>The same utilities can be used consistently across different runtime contexts</li> <li>Dependencies are properly injected and managed</li> </ul>"},{"location":"expose-type/","title":"Exposing Types for TypeScript Generation","text":"<p>The <code>@ExposeType</code> decorator allows you to explicitly expose types for TypeScript interface generation without requiring them to be directly referenced in REST endpoints, WebSocket messages, or as indirect dependencies.</p>"},{"location":"expose-type/#use-cases","title":"Use Cases","text":"<p>The <code>@ExposeType</code> decorator is useful when you have types that:</p> <ol> <li>Are used only on the frontend - Types that exist for frontend state management, validation, or business logic</li> <li>Are part of a shared schema - Common types that multiple parts of your application use but aren't directly in API contracts</li> <li>Need to be pre-generated - Types that you want available immediately even if they're not yet used in any endpoints</li> <li>Are utility types - Helper types, enums, or constants that the frontend needs to know about</li> </ol>"},{"location":"expose-type/#basic-usage","title":"Basic Usage","text":"<p>Simply decorate any Pydantic model with <code>@ExposeType()</code>:</p> <pre><code>from pydantic import BaseModel\n\nfrom jararaca import ExposeType\n\n\n@ExposeType()\nclass UserPermission(BaseModel):\n    id: str\n    name: str\n    description: str\n    resource: str\n    action: str\n</code></pre> <p>This type will now be included in the generated TypeScript output when you run:</p> <pre><code>jararaca gen-tsi app:app output.ts\n</code></pre>"},{"location":"expose-type/#example-frontend-only-types","title":"Example: Frontend-Only Types","text":"<pre><code>from pydantic import BaseModel\n\nfrom jararaca import ExposeType\n\n\n@ExposeType()\nclass FilterState(BaseModel):\n    \"\"\"Frontend state for table filtering.\"\"\"\n    search_query: str\n    sort_column: str\n    sort_direction: str\n    page: int\n    page_size: int\n\n@ExposeType()\nclass UITheme(BaseModel):\n    \"\"\"Frontend theme configuration.\"\"\"\n    primary_color: str\n    secondary_color: str\n    dark_mode: bool\n</code></pre>"},{"location":"expose-type/#example-error-codes-and-constants","title":"Example: Error Codes and Constants","text":"<pre><code>from enum import Enum\n\nfrom pydantic import BaseModel\n\nfrom jararaca import ExposeType\n\n\n@ExposeType()\nclass ErrorCode(str, Enum):\n    \"\"\"Standard error codes.\"\"\"\n    UNAUTHORIZED = \"UNAUTHORIZED\"\n    NOT_FOUND = \"NOT_FOUND\"\n    VALIDATION_ERROR = \"VALIDATION_ERROR\"\n    INTERNAL_ERROR = \"INTERNAL_ERROR\"\n\n@ExposeType()\nclass ApiErrorDetail(BaseModel):\n    \"\"\"Detailed error information.\"\"\"\n    code: ErrorCode\n    message: str\n    field: str | None = None\n    details: dict[str, str] | None = None\n</code></pre>"},{"location":"expose-type/#example-complex-nested-types","title":"Example: Complex Nested Types","text":"<pre><code>from pydantic import BaseModel\n\nfrom jararaca import ExposeType\n\n\n@ExposeType()\nclass Address(BaseModel):\n    street: str\n    city: str\n    country: str\n    postal_code: str\n\n@ExposeType()\nclass ContactInfo(BaseModel):\n    email: str\n    phone: str | None = None\n    address: Address\n\n@ExposeType()\nclass Organization(BaseModel):\n    \"\"\"Complete organization structure.\"\"\"\n    id: str\n    name: str\n    contacts: list[ContactInfo]\n    settings: dict[str, str]\n</code></pre> <p>When you expose a type with nested structures, the decorator ensures that all related types are also included in the TypeScript generation.</p>"},{"location":"expose-type/#comparison-with-vs-without-exposetype","title":"Comparison: With vs Without @ExposeType","text":""},{"location":"expose-type/#without-exposetype","title":"Without @ExposeType","text":"<pre><code>class UserRole(BaseModel):\n    \"\"\"Only generated if used in an endpoint or as a dependency.\"\"\"\n    id: str\n    name: str\n\n@RestController(\"/api/users\")\nclass UserController:\n    @Get(\"/{user_id}\")\n    async def get_user(self, user_id: str) -&gt; UserResponse:\n        # UserRole is only generated if UserResponse references it\n        return UserResponse(...)\n</code></pre>"},{"location":"expose-type/#with-exposetype","title":"With @ExposeType","text":"<pre><code>@ExposeType()\nclass UserRole(BaseModel):\n    \"\"\"Always generated, available immediately.\"\"\"\n    id: str\n    name: str\n\n@RestController(\"/api/users\")\nclass UserController:\n    @Get(\"/{user_id}\")\n    async def get_user(self, user_id: str) -&gt; UserResponse:\n        # UserRole is available in TypeScript even if not used yet\n        return UserResponse(...)\n</code></pre>"},{"location":"expose-type/#integration-with-other-decorators","title":"Integration with Other Decorators","text":"<p>The <code>@ExposeType</code> decorator works seamlessly with other TypeScript generation decorators:</p> <pre><code>from jararaca import ExposeType, SplitInputOutput\n\n\n@ExposeType()\n@SplitInputOutput()\nclass UserProfile(BaseModel):\n    \"\"\"Generates UserProfileInput and UserProfileOutput interfaces.\"\"\"\n    id: str\n    username: str\n    email: str\n    created_at: str\n    updated_at: str\n</code></pre> <p>This creates both <code>UserProfileInput</code> and <code>UserProfileOutput</code> TypeScript interfaces.</p>"},{"location":"expose-type/#best-practices","title":"Best Practices","text":"<ol> <li>Use for shared types: Apply <code>@ExposeType</code> to types that are used across multiple parts of your application</li> <li>Document the purpose: Add clear docstrings explaining why a type is exposed</li> <li>Avoid overuse: Only expose types that the frontend actually needs - don't expose internal implementation details</li> <li>Combine with other decorators: Use alongside <code>@SplitInputOutput</code> when appropriate</li> <li>Group related types: Keep exposed types in dedicated modules (e.g., <code>shared_types.py</code>)</li> </ol>"},{"location":"expose-type/#viewing-exposed-types","title":"Viewing Exposed Types","text":"<p>All types decorated with <code>@ExposeType</code> are tracked globally. You can check which types are exposed:</p> <pre><code>from jararaca.tools.typescript.decorators import ExposeType\n\n# Get all exposed types\nexposed = ExposeType.get_all_exposed_types()\nprint(f\"Exposed {len(exposed)} types: {[t.__name__ for t in exposed]}\")\n</code></pre>"},{"location":"expose-type/#generated-typescript","title":"Generated TypeScript","text":"<p>Given this Python code:</p> <pre><code>@ExposeType()\nclass NotificationPreference(BaseModel):\n    email_enabled: bool\n    push_enabled: bool\n    frequency: str\n</code></pre> <p>The generated TypeScript will be:</p> <pre><code>export interface NotificationPreference {\n  emailEnabled: boolean;\n  pushEnabled: boolean;\n  frequency: string;\n}\n</code></pre> <p>The type is available in your TypeScript code even if no REST endpoint uses it yet.</p>"},{"location":"http-rpc/","title":"HTTP RPC Client","text":"<p>The Jararaca HTTP RPC client provides a complete REST client implementation with a decorator-based approach for defining HTTP endpoints. It includes advanced features like authentication, caching, retry logic, form data handling, and file uploads.</p>"},{"location":"http-rpc/#quick-start","title":"Quick Start","text":"<pre><code>from jararaca.rpc.http import (\n    BearerTokenAuth,\n    Body,\n    CacheMiddleware,\n    Delete,\n    File,\n    FormData,\n    Get,\n    HttpRpcClientBuilder,\n    HTTPXHttpRPCAsyncBackend,\n    Post,\n    Put,\n    Query,\n    RestClient,\n    Retry,\n    RetryConfig,\n)\n\n\n@RestClient(\"https://api.example.com\")\nclass ApiClient:\n\n    @Get(\"/users\")\n    @Query(\"limit\")\n    async def get_users(self, limit: int) -&gt; dict:\n        pass\n\n    @Post(\"/users\")\n    @Body(\"user_data\")\n    async def create_user(self, user_data: dict) -&gt; dict:\n        pass\n\n# Create client\nbackend = HTTPXHttpRPCAsyncBackend()\nauth = BearerTokenAuth(\"your-token\")\ncache = CacheMiddleware(ttl_seconds=300)\n\nbuilder = HttpRpcClientBuilder(\n    backend=backend,\n    middlewares=[auth, cache]\n)\n\nclient = builder.build(ApiClient)\n\n# Use client\nusers = await client.get_users(10)\nnew_user = await client.create_user({\"name\": \"John\", \"email\": \"john@example.com\"})\n</code></pre>"},{"location":"http-rpc/#http-method-decorators","title":"HTTP Method Decorators","text":""},{"location":"http-rpc/#basic-http-methods","title":"Basic HTTP Methods","text":"<pre><code>from jararaca.rpc.http import Delete, Get, Patch, Post, Put\n\n\n@RestClient(\"https://api.example.com\")\nclass ApiClient:\n\n    @Get(\"/users\")\n    async def get_users(self) -&gt; list[dict]:\n        pass\n\n    @Post(\"/users\")\n    async def create_user(self) -&gt; dict:\n        pass\n\n    @Put(\"/users/{user_id}\")\n    async def update_user(self) -&gt; dict:\n        pass\n\n    @Patch(\"/users/{user_id}\")\n    async def patch_user(self) -&gt; dict:\n        pass\n\n    @Delete(\"/users/{user_id}\")\n    async def delete_user(self) -&gt; bool:\n        pass\n</code></pre>"},{"location":"http-rpc/#request-parameter-decorators","title":"Request Parameter Decorators","text":""},{"location":"http-rpc/#query-parameters","title":"Query Parameters","text":"<pre><code>from jararaca.rpc.http import Query\n\n\n@Get(\"/users\")\n@Query(\"limit\")\n@Query(\"offset\")\nasync def get_users(self, limit: int, offset: int = 0) -&gt; list[dict]:\n    pass\n\n# Usage: client.get_users(10, 20) -&gt; GET /users?limit=10&amp;offset=20\n</code></pre>"},{"location":"http-rpc/#path-parameters","title":"Path Parameters","text":"<pre><code>from jararaca.rpc.http import PathParam\n\n\n@Get(\"/users/{user_id}\")\n@PathParam(\"user_id\")\nasync def get_user(self, user_id: int) -&gt; dict:\n    pass\n\n# Usage: client.get_user(123) -&gt; GET /users/123\n</code></pre>"},{"location":"http-rpc/#headers","title":"Headers","text":"<pre><code>from jararaca.rpc.http import Header\n\n\n@Get(\"/users\")\n@Header(\"X-Client-Version\")\nasync def get_users(self, x_client_version: str = \"1.0\") -&gt; list[dict]:\n    pass\n\n# Usage: client.get_users(\"2.0\") -&gt; adds X-Client-Version: 2.0 header\n</code></pre>"},{"location":"http-rpc/#request-body","title":"Request Body","text":"<pre><code>from jararaca.rpc.http import Body\n\n\n@Post(\"/users\")\n@Body(\"user_data\")\nasync def create_user(self, user_data: dict) -&gt; dict:\n    pass\n\n# Usage: client.create_user({\"name\": \"John\"}) -&gt; sends JSON body\n</code></pre>"},{"location":"http-rpc/#form-data","title":"Form Data","text":"<pre><code>from jararaca.rpc.http import FormData\n\n\n@Post(\"/login\")\n@FormData(\"username\")\n@FormData(\"password\")\nasync def login(self, username: str, password: str) -&gt; dict:\n    pass\n\n# Usage: client.login(\"user\", \"pass\") -&gt; sends form-encoded data\n</code></pre>"},{"location":"http-rpc/#file-uploads","title":"File Uploads","text":"<pre><code>from jararaca.rpc.http import File, FormData\n\n\n@Post(\"/upload\")\n@FormData(\"name\")\n@File(\"avatar\")\nasync def upload_avatar(self, name: str, avatar: bytes) -&gt; dict:\n    pass\n\n# Usage:\n# with open(\"avatar.jpg\", \"rb\") as f:\n#     result = await client.upload_avatar(\"John\", f.read())\n</code></pre>"},{"location":"http-rpc/#configuration-decorators","title":"Configuration Decorators","text":""},{"location":"http-rpc/#timeout","title":"Timeout","text":"<pre><code>from jararaca.rpc.http import Timeout\n\n\n@Get(\"/slow-endpoint\")\n@Timeout(30.0)  # 30 seconds timeout\nasync def slow_request(self) -&gt; dict:\n    pass\n</code></pre>"},{"location":"http-rpc/#retry-configuration","title":"Retry Configuration","text":"<pre><code>from jararaca.rpc.http import Retry, RetryConfig\n\n\n@Get(\"/unreliable-endpoint\")\n@Retry(RetryConfig(\n    max_attempts=3,\n    backoff_factor=2.0,\n    retry_on_status_codes=[500, 502, 503, 504]\n))\nasync def unreliable_request(self) -&gt; dict:\n    pass\n</code></pre>"},{"location":"http-rpc/#content-type","title":"Content Type","text":"<pre><code>from jararaca.rpc.http import ContentType\n\n\n@Post(\"/xml-endpoint\")\n@ContentType(\"application/xml\")\n@Body(\"xml_data\")\nasync def send_xml(self, xml_data: str) -&gt; dict:\n    pass\n</code></pre>"},{"location":"http-rpc/#authentication","title":"Authentication","text":""},{"location":"http-rpc/#bearer-token-authentication","title":"Bearer Token Authentication","text":"<pre><code>from jararaca.rpc.http import BearerTokenAuth\n\nauth = BearerTokenAuth(\"your-access-token\")\nbuilder = HttpRpcClientBuilder(backend=backend, middlewares=[auth])\n</code></pre>"},{"location":"http-rpc/#basic-authentication","title":"Basic Authentication","text":"<pre><code>from jararaca.rpc.http import BasicAuth\n\nauth = BasicAuth(\"username\", \"password\")\nbuilder = HttpRpcClientBuilder(backend=backend, middlewares=[auth])\n</code></pre>"},{"location":"http-rpc/#api-key-authentication","title":"API Key Authentication","text":"<pre><code>from jararaca.rpc.http import ApiKeyAuth\n\nauth = ApiKeyAuth(\"your-api-key\", header_name=\"X-API-Key\")\nbuilder = HttpRpcClientBuilder(backend=backend, middlewares=[auth])\n</code></pre>"},{"location":"http-rpc/#middleware","title":"Middleware","text":""},{"location":"http-rpc/#cache-middleware","title":"Cache Middleware","text":"<p>The cache middleware provides in-memory caching for GET requests:</p> <pre><code>from jararaca.rpc.http import CacheMiddleware\n\ncache = CacheMiddleware(ttl_seconds=300)  # Cache for 5 minutes\nbuilder = HttpRpcClientBuilder(backend=backend, middlewares=[cache])\n</code></pre>"},{"location":"http-rpc/#custom-request-middleware","title":"Custom Request Middleware","text":"<pre><code>from jararaca.rpc.http import HttpRPCRequest, RequestMiddleware\n\n\nclass LoggingMiddleware(RequestMiddleware):\n    def on_request(self, request: HttpRPCRequest) -&gt; HttpRPCRequest:\n        print(f\"Making request to {request.url}\")\n        return request\n\nlogging_middleware = LoggingMiddleware()\nbuilder = HttpRpcClientBuilder(backend=backend, middlewares=[logging_middleware])\n</code></pre>"},{"location":"http-rpc/#response-middleware","title":"Response Middleware","text":"<pre><code>from jararaca.rpc.http import HttpRPCRequest, HttpRPCResponse, ResponseMiddleware\n\n\nclass ResponseLoggingMiddleware(ResponseMiddleware):\n    def on_response(self, request: HttpRPCRequest, response: HttpRPCResponse) -&gt; HttpRPCResponse:\n        print(f\"Response from {request.url}: {response.status_code}\")\n        return response\n\nresponse_middleware = ResponseLoggingMiddleware()\nbuilder = HttpRpcClientBuilder(\n    backend=backend,\n    response_middlewares=[response_middleware]\n)\n</code></pre>"},{"location":"http-rpc/#hooks","title":"Hooks","text":""},{"location":"http-rpc/#request-hooks","title":"Request Hooks","text":"<pre><code>from jararaca.rpc.http import HttpRPCRequest, RequestHook\n\n\nclass RequestTimingHook(RequestHook):\n    def before_request(self, request: HttpRPCRequest) -&gt; HttpRPCRequest:\n        request.start_time = time.time()\n        return request\n\ntiming_hook = RequestTimingHook()\nbuilder = HttpRpcClientBuilder(\n    backend=backend,\n    request_hooks=[timing_hook]\n)\n</code></pre>"},{"location":"http-rpc/#response-hooks","title":"Response Hooks","text":"<pre><code>from jararaca.rpc.http import HttpRPCRequest, HttpRPCResponse, ResponseHook\n\n\nclass ResponseTimingHook(ResponseHook):\n    def after_response(self, request: HttpRPCRequest, response: HttpRPCResponse) -&gt; HttpRPCResponse:\n        if hasattr(request, 'start_time'):\n            elapsed = time.time() - request.start_time\n            print(f\"Request took {elapsed:.2f} seconds\")\n        return response\n\ntiming_hook = ResponseTimingHook()\nbuilder = HttpRpcClientBuilder(\n    backend=backend,\n    response_hooks=[timing_hook]\n)\n</code></pre>"},{"location":"http-rpc/#error-handling","title":"Error Handling","text":""},{"location":"http-rpc/#global-error-handlers","title":"Global Error Handlers","text":"<pre><code>from jararaca.rpc.http import GlobalHttpErrorHandler\n\n\n@GlobalHttpErrorHandler(404)\ndef handle_not_found(request, response):\n    return {\"error\": \"Resource not found\"}\n\n@GlobalHttpErrorHandler(500)\ndef handle_server_error(request, response):\n    return {\"error\": \"Server error occurred\"}\n</code></pre>"},{"location":"http-rpc/#route-specific-error-handlers","title":"Route-Specific Error Handlers","text":"<pre><code>from jararaca.rpc.http import RouteHttpErrorHandler\n\n\n@Get(\"/users/{user_id}\")\n@PathParam(\"user_id\")\n@RouteHttpErrorHandler(404)\ndef handle_user_not_found(request, response):\n    return {\"error\": f\"User not found\"}\nasync def get_user(self, user_id: int) -&gt; dict:\n    pass\n</code></pre>"},{"location":"http-rpc/#advanced-features","title":"Advanced Features","text":""},{"location":"http-rpc/#complete-example-with-all-features","title":"Complete Example with All Features","text":"<pre><code>import asyncio\n\nfrom jararaca.rpc.http import (\n    ApiKeyAuth,\n    BasicAuth,\n    BearerTokenAuth,\n    Body,\n    CacheMiddleware,\n    ContentType,\n    Delete,\n    File,\n    FormData,\n    Get,\n    GlobalHttpErrorHandler,\n    Header,\n    HttpRpcClientBuilder,\n    HTTPXHttpRPCAsyncBackend,\n    PathParam,\n    Post,\n    Put,\n    Query,\n    RequestHook,\n    ResponseHook,\n    ResponseMiddleware,\n    RestClient,\n    Retry,\n    RetryConfig,\n    RouteHttpErrorHandler,\n    Timeout,\n)\n\n\n# Custom middleware\nclass RequestIdMiddleware(RequestMiddleware):\n    def on_request(self, request: HttpRPCRequest) -&gt; HttpRPCRequest:\n        import uuid\n        request.headers.append((\"X-Request-ID\", str(uuid.uuid4())))\n        return request\n\n# Error handlers\n@GlobalHttpErrorHandler(500)\ndef handle_server_error(request, response):\n    return {\"error\": \"Server error\", \"status\": 500}\n\n@RestClient(\"https://api.example.com/v1\")\nclass AdvancedApiClient:\n\n    @Get(\"/users\")\n    @Query(\"limit\")\n    @Query(\"search\")\n    @Header(\"X-Client-Version\")\n    @Timeout(10.0)\n    @CacheMiddleware(ttl_seconds=60)\n    async def search_users(\n        self,\n        limit: int = 10,\n        search: str = \"\",\n        x_client_version: str = \"1.0\"\n    ) -&gt; list[dict]:\n        pass\n\n    @Post(\"/users\")\n    @Body(\"user_data\")\n    @ContentType(\"application/json\")\n    @Retry(RetryConfig(max_attempts=3, backoff_factor=1.5))\n    @RouteHttpErrorHandler(400)\n    def handle_validation_error(request, response):\n        return {\"error\": \"Validation failed\", \"details\": response.data}\n    async def create_user(self, user_data: dict) -&gt; dict:\n        pass\n\n    @Put(\"/users/{user_id}/avatar\")\n    @PathParam(\"user_id\")\n    @File(\"avatar\")\n    @FormData(\"description\")\n    @Timeout(30.0)\n    async def upload_user_avatar(\n        self,\n        user_id: int,\n        avatar: bytes,\n        description: str = \"\"\n    ) -&gt; dict:\n        pass\n\n    @Delete(\"/users/{user_id}\")\n    @PathParam(\"user_id\")\n    @Retry(RetryConfig(max_attempts=2))\n    async def delete_user(self, user_id: int) -&gt; bool:\n        pass\n\nasync def main():\n    # Setup backend and middleware\n    backend = HTTPXHttpRPCAsyncBackend(default_timeout=15.0)\n    auth = BearerTokenAuth(\"your-access-token\")\n    cache = CacheMiddleware(ttl_seconds=300)\n    request_id = RequestIdMiddleware()\n\n    # Build client with all features\n    builder = HttpRpcClientBuilder(\n        backend=backend,\n        middlewares=[auth, cache, request_id],\n        response_middlewares=[],\n        request_hooks=[],\n        response_hooks=[]\n    )\n\n    client = builder.build(AdvancedApiClient)\n\n    try:\n        # Use the client\n        users = await client.search_users(limit=20, search=\"john\")\n        new_user = await client.create_user({\n            \"name\": \"Jane Doe\",\n            \"email\": \"jane@example.com\"\n        })\n\n        # Upload avatar\n        with open(\"avatar.jpg\", \"rb\") as f:\n            avatar_result = await client.upload_user_avatar(\n                user_id=new_user[\"id\"],\n                avatar=f.read(),\n                description=\"Profile picture\"\n            )\n\n        print(\"\u2705 All operations completed successfully\")\n\n    except Exception as e:\n        print(f\"\u274c Error: {e}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"http-rpc/#backend-configuration","title":"Backend Configuration","text":""},{"location":"http-rpc/#httpx-backend-options","title":"HTTPX Backend Options","text":"<pre><code>from jararaca.rpc.http import HTTPXHttpRPCAsyncBackend\n\nbackend = HTTPXHttpRPCAsyncBackend(\n    prefix_url=\"https://api.example.com\",  # Base URL for all requests\n    default_timeout=30.0  # Default timeout in seconds\n)\n</code></pre>"},{"location":"http-rpc/#exception-handling","title":"Exception Handling","text":"<p>The HTTP RPC client provides several exception types:</p> <ul> <li><code>TimeoutException</code>: Raised when a request times out</li> <li><code>RPCRequestNetworkError</code>: Raised for network-related errors</li> <li><code>RPCUnhandleError</code>: Raised when no error handler matches the response status</li> </ul> <pre><code>from jararaca.rpc.http import RPCRequestNetworkError, RPCUnhandleError, TimeoutException\n\ntry:\n    result = await client.get_users()\nexcept TimeoutException:\n    print(\"Request timed out\")\nexcept RPCRequestNetworkError:\n    print(\"Network error occurred\")\nexcept RPCUnhandleError as e:\n    print(f\"Unhandled error: {e.response.status_code}\")\n</code></pre>"},{"location":"http-rpc/#best-practices","title":"Best Practices","text":"<ol> <li>Use Type Hints: Always provide type hints for better IDE support and documentation</li> <li>Error Handling: Implement appropriate error handlers for expected error conditions</li> <li>Timeouts: Set reasonable timeouts for all requests</li> <li>Retry Logic: Use retry configuration for operations that may fail temporarily</li> <li>Caching: Use cache middleware for read-heavy operations</li> <li>Authentication: Store tokens securely and refresh them as needed</li> <li>Middleware Order: Consider the order of middleware execution</li> <li>Resource Management: Use async context managers when appropriate</li> </ol>"},{"location":"http-rpc/#migration-from-previous-versions","title":"Migration from Previous Versions","text":"<p>If you're upgrading from a previous version of the HTTP RPC client, here are the key changes:</p> <ol> <li>New Decorators: <code>@FormData</code>, <code>@File</code>, <code>@Timeout</code>, <code>@Retry</code>, <code>@ContentType</code></li> <li>Authentication: New authentication middleware classes</li> <li>Caching: Built-in cache middleware</li> <li>Enhanced Error Handling: More granular exception types</li> <li>Middleware System: Expanded middleware and hooks system</li> <li>Form Data Support: Native support for form submissions and file uploads</li> </ol> <p>All existing functionality remains backward compatible.</p>"},{"location":"interceptors/","title":"Interceptors in Jararaca","text":"<p>Interceptors are a powerful mechanism in Jararaca for implementing cross-cutting concerns across different execution contexts. They allow you to wrap the execution of HTTP requests, message handling, scheduled tasks, and WebSocket communications with common behaviors such as transaction management, message publishing, and WebSocket message dispatching.</p>"},{"location":"interceptors/#overview-of-the-interceptor-system","title":"Overview of the Interceptor System","text":"<p>Interceptors in Jararaca work by wrapping the execution of handlers in different contexts:</p> <ul> <li>HTTP Controllers: Intercept incoming HTTP requests before they reach controllers</li> <li>Message Bus Consumers: Intercept message processing in workers</li> <li>Scheduled Tasks: Intercept scheduled task execution</li> <li>WebSocket Connections: Manage WebSocket connections and message dispatching</li> </ul> <p>Each interceptor provides a specific capability to the application through context variables, allowing your code to access these capabilities through hook functions like <code>use_session()</code>, <code>use_publisher()</code>, and <code>use_ws_manager()</code>.</p>"},{"location":"interceptors/#the-atomic-layer-transactions-messages-and-websockets","title":"The Atomic Layer: Transactions, Messages, and WebSockets","text":"<p>The true power of the interceptor system lies in how it creates an atomic layer that ensures consistency across database operations, message publishing, and WebSocket communications. This is particularly important for implementing transactional outbox patterns and ensuring consistency in distributed systems.</p> <pre><code>sequenceDiagram\n    participant Client\n    participant HTTP Context\n    participant DB Interceptor\n    participant MessageBus Interceptor\n    participant WebSocket Interceptor\n    participant Database\n    participant MessageBroker\n    participant WebSocketBackend\n\n    Client-&gt;&gt;HTTP Context: HTTP Request\n    Note over HTTP Context,WebSocketBackend: Transaction Boundary Begins\n\n    HTTP Context-&gt;&gt;DB Interceptor: Begin Transaction\n    DB Interceptor-&gt;&gt;Database: Begin DB Transaction\n\n    HTTP Context-&gt;&gt;MessageBus Interceptor: Stage Messages\n    MessageBus Interceptor-&gt;&gt;MessageBus Interceptor: Queue Messages\n\n    HTTP Context-&gt;&gt;WebSocket Interceptor: Stage WebSocket Messages\n    WebSocket Interceptor-&gt;&gt;WebSocket Interceptor: Queue WebSocket Messages\n\n    HTTP Context-&gt;&gt;DB Interceptor: Commit Transaction\n    DB Interceptor-&gt;&gt;Database: Commit DB Transaction\n    Database--&gt;&gt;DB Interceptor: Success\n\n    DB Interceptor--&gt;&gt;MessageBus Interceptor: DB Commit Success\n    MessageBus Interceptor-&gt;&gt;MessageBroker: Flush Queued Messages\n\n    MessageBus Interceptor--&gt;&gt;WebSocket Interceptor: Messages Published\n    WebSocket Interceptor-&gt;&gt;WebSocketBackend: Flush WebSocket Messages\n\n    Note over HTTP Context,WebSocketBackend: Transaction Boundary Ends\n\n    HTTP Context--&gt;&gt;Client: HTTP Response\n</code></pre>"},{"location":"interceptors/#order-of-interceptors-matters","title":"Order of Interceptors Matters","text":"<p>The order in which interceptors are configured in your application is critical. The typical order is:</p> <ol> <li>Configuration Interceptor - Loads and provides application configuration</li> <li>Message Bus Publisher Interceptor - Provides message publishing capabilities</li> <li>Database Session Interceptor - Provides database transaction capabilities</li> <li>WebSocket Interceptor - Provides WebSocket communication capabilities</li> </ol> <p>This order ensures that:</p> <ol> <li>The database transaction is committed first</li> <li>Only after successful database commit, messages are published to the message broker</li> <li>Finally, WebSocket messages are dispatched to connected clients</li> </ol>"},{"location":"interceptors/#implementing-transactional-outbox-pattern","title":"Implementing Transactional Outbox Pattern","text":"<p>Jararaca's interceptor system makes implementing the transactional outbox pattern straightforward. This pattern ensures that database changes and message publishing are atomic:</p> <pre><code>from jararaca.persistence.session import use_session\nfrom jararaca.messagebus.publisher import use_publisher\n\nasync def create_user(user_data: dict):\n    # Get the current database session from the context\n    session = use_session()\n\n    # Get the message publisher from the context\n    publisher = use_publisher()\n\n    # Create user in database\n    new_user = User(**user_data)\n    session.add(new_user)\n\n    # Stage a message to be published after successful transaction\n    await publisher.publish(\"user_created\", UserCreatedEvent(id=new_user.id))\n\n    # The actual database commit and message publishing\n    # happens automatically when the request handling is complete,\n    # managed by the interceptors\n</code></pre> <p>When this code executes: 1. The database session interceptor ensures the user is committed to the database 2. If the database transaction succeeds, the message bus interceptor publishes the staged message 3. If the database transaction fails, no messages are published</p>"},{"location":"interceptors/#contexts-and-interceptors","title":"Contexts and Interceptors","text":"<p>Jararaca supports different execution contexts, and interceptors behave differently in each:</p>"},{"location":"interceptors/#http-context","title":"HTTP Context","text":"<p>In an HTTP context, all interceptors are active: - Database Session Interceptor manages transactions - Message Bus Publisher Interceptor stages and flushes messages - WebSocket Interceptor stages and flushes WebSocket messages</p>"},{"location":"interceptors/#worker-context","title":"Worker Context","text":"<p>In a message bus worker context: - Database Session Interceptor manages transactions - Message Bus Publisher Interceptor stages and flushes messages - WebSocket Interceptor stages and flushes WebSocket messages</p>"},{"location":"interceptors/#scheduler-context","title":"Scheduler Context","text":"<p>In a scheduler context: - Database Session Interceptor manages transactions - Message Bus Publisher Interceptor stages and flushes messages - WebSocket Interceptor stages and flushes WebSocket messages</p>"},{"location":"interceptors/#websocket-context","title":"WebSocket Context","text":"<p>In a WebSocket context: - Database Session Interceptor manages transactions - Message Bus Publisher is usually not active (as defined in the <code>intercept</code> method) - WebSocket communications are managed directly</p>"},{"location":"interceptors/#code-example-configuring-interceptors","title":"Code Example: Configuring Interceptors","text":"<pre><code>from jararaca import Microservice\nfrom jararaca.persistence.interceptors import AIOSqlAlchemySessionInterceptor, AIOSQAConfig\nfrom jararaca.messagebus.interceptors import MessageBusPublisherInterceptor\nfrom jararaca.presentation.websocket import WebSocketInterceptor\n\n# Create the microservice\nmicroservice = Microservice(\n    name=\"my-service\",\n    interceptors=[\n        # Configuration interceptor (if any)\n        # ...\n\n        # Message bus interceptor\n        lambda config: MessageBusPublisherInterceptor(\n            connection_factory=message_publisher_factory,\n            connection_name=\"default\",\n            message_scheduler=message_scheduler,\n        ),\n\n        # Database session interceptor\n        lambda config: AIOSqlAlchemySessionInterceptor(\n            AIOSQAConfig(\n                url=\"postgresql+asyncpg://user:password@localhost/dbname\",\n                connection_name=\"default\",\n                inject_default=True,\n            )\n        ),\n\n        # WebSocket interceptor\n        lambda config: WebSocketInterceptor(\n            backend=redis_websocket_backend,\n        ),\n    ],\n    # Other microservice configuration...\n)\n</code></pre>"},{"location":"interceptors/#best-practices","title":"Best Practices","text":"<ol> <li>Order Matters: Always configure interceptors in the order: configuration \u2192 message bus \u2192 database \u2192 WebSocket</li> <li>Transaction Boundaries: Be aware that interceptors create implicit transaction boundaries</li> <li>Error Handling: Database errors will prevent message publishing and WebSocket dispatching</li> <li>Idempotency: Design your message handlers to be idempotent in case of retries</li> <li>Context Variables: Use the appropriate context hooks (<code>use_session()</code>, <code>use_publisher()</code>, etc.) to access the capabilities provided by interceptors</li> </ol>"},{"location":"interceptors/#advanced-usage-custom-interceptors","title":"Advanced Usage: Custom Interceptors","text":"<p>You can create custom interceptors by implementing the <code>AppInterceptor</code> interface:</p> <pre><code>from contextlib import asynccontextmanager\nfrom typing import AsyncGenerator\nfrom jararaca.microservice import AppInterceptor, AppTransactionContext\n\nclass CustomInterceptor(AppInterceptor):\n    @asynccontextmanager\n    async def intercept(self, app_context: AppTransactionContext) -&gt; AsyncGenerator[None, None]:\n        # Pre-processing logic\n\n        try:\n            # Let the request handler execute\n            yield\n            # Post-processing after successful execution\n        except Exception as e:\n            # Handle exceptions\n            raise e\n</code></pre>"},{"location":"interceptors/#conclusion","title":"Conclusion","text":"<p>Jararaca's interceptor system provides a powerful way to implement cross-cutting concerns and ensure consistency across database operations, message publishing, and WebSocket communications. By properly configuring interceptors, you can implement patterns like the transactional outbox pattern with minimal effort, ensuring that your distributed system maintains consistency even in the face of failures.</p>"},{"location":"messagebus/","title":"Jararaca Message Bus Architecture","text":"<p>The message bus system in Jararaca provides a robust infrastructure for asynchronous message processing using a publisher-consumer pattern. This document explains how the message bus works, from message definition to processing flows.</p>"},{"location":"messagebus/#overview","title":"Overview","text":"<p>The message bus system consists of several key components that work together to provide a seamless experience for defining, publishing, and consuming messages.</p> <pre><code>graph TB\n    subgraph \"Message Definition\"\n        Message[Message]\n        MessageOf[MessageOf]\n    end\n\n    subgraph \"Message Handling\"\n        MessageHandler[MessageHandler]\n        MessageBusController[MessageBusController]\n        BusMessageController[BusMessageController]\n    end\n\n    subgraph \"Worker Infrastructure\"\n        MessageBusWorker[MessageBusWorker]\n        AioPikaMicroserviceConsumer[AioPikaMicroserviceConsumer]\n        MessageHandlerCallback[MessageHandlerCallback]\n    end\n\n    subgraph \"Utilities\"\n        ack[ack]\n        nack[nack]\n        retry[retry]\n        retry_later[retry_later]\n        reject[reject]\n    end\n\n    Message --&gt; MessageOf\n    MessageHandler --&gt; MessageBusController\n    MessageBusController --&gt; MessageBusWorker\n    MessageBusWorker --&gt; AioPikaMicroserviceConsumer\n    AioPikaMicroserviceConsumer --&gt; MessageHandlerCallback\n    MessageHandlerCallback --&gt; BusMessageController\n    BusMessageController --&gt; ack\n    BusMessageController --&gt; nack\n    BusMessageController --&gt; reject\n    BusMessageController --&gt; retry\n    BusMessageController --&gt; retry_later\n</code></pre>"},{"location":"messagebus/#message-structure","title":"Message Structure","text":"<p>Messages in Jararaca are built on Pydantic models, which provide type validation and serialization capabilities.</p>"},{"location":"messagebus/#message-types-tasks-vs-events","title":"Message Types: Tasks vs Events","text":"<p>Jararaca supports two fundamental message types:</p> <ul> <li> <p>Tasks: Designed to be handled exactly once by a single MessageHandler. It is not recommended to have multiple MessageHandlers listening to the same Task type. Tasks represent commands or operations that should be executed once.</p> </li> <li> <p>Events: Can be listened to by multiple parts of the application. Events are ideal for scenarios where different components need to react to the same occurrence, providing looser coupling throughout the codebase.</p> </li> </ul> <pre><code>graph LR\n    Task[Task Message] --&gt; Handler1[Single Handler]\n    Event[Event Message] --&gt; HandlerA[Handler A]\n    Event --&gt; HandlerB[Handler B]\n    Event --&gt; HandlerC[Handler C]\n</code></pre> <p>When designing your message architecture, consider:</p> <ul> <li>Use Tasks when an operation should be performed exactly once</li> <li>Use Events when multiple systems need to react to the same occurrence</li> <li>Events promote better decoupling between components</li> </ul>"},{"location":"messagebus/#base-message-class","title":"Base Message Class","text":"<pre><code>classDiagram\n    class Message {\n        +MESSAGE_TOPIC: ClassVar[str]\n        +MESSAGE_TYPE: ClassVar[Literal[\"task\", \"event\"]]\n        +publish() async\n    }\n    class BaseModel {\n        +model_validate_json()\n        +json()\n    }\n    class UserCreatedMessage {\n        +MESSAGE_TOPIC: \"user.created\"\n        +MESSAGE_TYPE: \"event\"\n        +user_id: str\n        +username: str\n        +email: str\n    }\n    BaseModel &lt;|-- Message\n    Message &lt;|-- UserCreatedMessage\n</code></pre>"},{"location":"messagebus/#example-message-definition","title":"Example Message Definition","text":"<pre><code>from jararaca import Message\n\n\nclass UserCreatedMessage(Message):\n    MESSAGE_TOPIC = \"user.created\"\n    MESSAGE_TYPE = \"event\"  # or \"task\"\n\n    user_id: str\n    username: str\n    email: str\n</code></pre>"},{"location":"messagebus/#message-processing-flow","title":"Message Processing Flow","text":"<p>When a message is published, it goes through several processing stages before being handled by the appropriate consumer.</p> <pre><code>sequenceDiagram\n    participant P as Publisher\n    participant E as Exchange (RabbitMQ)\n    participant Q as Queue\n    participant W as MessageBusWorker\n    participant C as Consumer (Handler)\n\n    P-&gt;&gt;E: publish(message, topic)\n    E-&gt;&gt;Q: route message by topic\n    W-&gt;&gt;Q: consume messages\n    Q-&gt;&gt;W: deliver message\n    W-&gt;&gt;C: invoke message handler\n    C-&gt;&gt;W: process &amp; acknowledge\n</code></pre>"},{"location":"messagebus/#message-routing-exchanges-and-queues","title":"Message Routing: Exchanges and Queues","text":"<p>Jararaca's message bus system leverages RabbitMQ's exchange and queue architecture to efficiently route messages between publishers and consumers.</p>"},{"location":"messagebus/#exchange-and-queue-structure-example","title":"Exchange and Queue Structure Example","text":"<p>The following diagram illustrates how the exchange and queue system works in a typical Jararaca application:</p> <pre><code>graph LR\n    subgraph Publishers\n        P1[UserService]\n        P2[OrderService]\n        P3[NotificationService]\n    end\n\n    subgraph \"Exchange (jararaca_ex)\"\n        E[Topic Exchange]\n    end\n\n    subgraph Queues\n        Q1[user_service_queue]\n        Q2[order_service_queue]\n        Q3[notification_service_queue]\n        Q4[analytics_service_queue]\n    end\n\n    subgraph Consumers\n        C1[UserServiceHandler]\n        C2[OrderServiceHandler]\n        C3[NotificationServiceHandler]\n        C4[AnalyticsServiceHandler]\n    end\n\n    P1 --&gt;|user.created| E\n    P1 --&gt;|user.updated| E\n    P2 --&gt;|order.created| E\n    P2 --&gt;|order.updated| E\n    P3 --&gt;|notification.sent| E\n\n    E --&gt;|user.created| Q1\n    E --&gt;|user.updated| Q1\n    E --&gt;|order.created| Q2\n    E --&gt;|order.updated| Q2\n    E --&gt;|notification.sent| Q3\n\n    %% Events can be routed to multiple queues\n    E --&gt;|user.created| Q4\n    E --&gt;|order.created| Q4\n\n    Q1 --&gt; C1\n    Q2 --&gt; C2\n    Q3 --&gt; C3\n    Q4 --&gt; C4\n\n    style E fill:#f96,stroke:#333,stroke-width:2px\n    style Q1 fill:#9cf,stroke:#333,stroke-width:1px\n    style Q2 fill:#9cf,stroke:#333,stroke-width:1px\n    style Q3 fill:#9cf,stroke:#333,stroke-width:1px\n    style Q4 fill:#9cf,stroke:#333,stroke-width:1px\n</code></pre>"},{"location":"messagebus/#how-message-routing-works","title":"How Message Routing Works","text":"<ol> <li>Publishers send messages to the exchange with a specific topic (e.g., <code>user.created</code>, <code>order.updated</code>).</li> <li>The Exchange routes these messages to queues based on binding patterns.</li> <li>Queues hold messages until they are consumed.</li> <li>Consumers process messages from their assigned queues.</li> </ol>"},{"location":"messagebus/#key-concepts","title":"Key Concepts:","text":"<ul> <li>Topic-based routing: Messages are routed based on their topic (e.g., <code>user.created</code>)</li> <li>Multiple bindings: A single exchange can route to multiple queues (especially useful for event messages)</li> <li>Service isolation: Each service typically has its own queue</li> <li>Message persistence: Messages remain in queues until processed, even if consumers are temporarily unavailable</li> </ul>"},{"location":"messagebus/#example-queue-binding-configuration","title":"Example Queue Binding Configuration","text":"<pre><code>from jararaca import MessageBusController, MessageHandler\nfrom jararaca.messagebus.worker import AioPikaWorkerConfig\n\n# Define worker configuration with queue binding patterns\nworker_config = AioPikaWorkerConfig(\n    url=\"amqp://guest:guest@localhost/\",\n    exchange=\"jararaca_ex\",\n    queue=\"user_service_queue\",\n    binding_keys=[\"user.*\", \"notification.user.*\"]  # This queue receives all user-related topics\n)\n</code></pre> <p>This message routing architecture allows for flexible and scalable communication patterns between different parts of your application, supporting both direct task assignment and broad event publishing.</p>"},{"location":"messagebus/#worker-infrastructure","title":"Worker Infrastructure","text":"<p>The MessageBusWorker is the central piece that orchestrates message consumption and processing.</p> <pre><code>classDiagram\n    class MessageBusWorker {\n        -app: Microservice\n        -config: AioPikaWorkerConfig\n        -container: Container\n        -lifecycle: AppLifecycle\n        -uow_context_provider: UnitOfWorkContextProvider\n        -_consumer: AioPikaMicroserviceConsumer\n        +start_async()\n        +start_sync()\n    }\n\n    class AioPikaMicroserviceConsumer {\n        -config: AioPikaWorkerConfig\n        -message_handler_set: Set[MessageHandlerData]\n        -incoming_map: Dict[str, MessageHandlerData]\n        -uow_context_provider: UnitOfWorkContextProvider\n        -shutdown_event: Event\n        -lock: Lock\n        -tasks: Set[Task]\n        +consume()\n        +wait_all_tasks_done()\n    }\n\n    class MessageHandlerCallback {\n        -consumer: AioPikaMicroserviceConsumer\n        -queue_name: str\n        -routing_key: str\n        -message_handler: MessageHandlerData\n        +message_consumer()\n        +handle_message_consume_done()\n        +handle_reject_message()\n        +handle_message()\n    }\n\n    MessageBusWorker --&gt; AioPikaMicroserviceConsumer\n    AioPikaMicroserviceConsumer --&gt; MessageHandlerCallback\n</code></pre>"},{"location":"messagebus/#worker-initialization-process","title":"Worker Initialization Process","text":"<pre><code>flowchart TD\n    A[MessageBusWorker Initialization] --&gt; B[Load App Controllers]\n    B --&gt; C[Find MessageBusControllers]\n    C --&gt; D[Extract Message Handlers]\n    D --&gt; E[Create AioPikaMicroserviceConsumer]\n    E --&gt; F[Connect to RabbitMQ]\n    F --&gt; G[Declare Exchanges &amp; Queues]\n    G --&gt; H[Bind Queues to Topics]\n    H --&gt; I[Start Consuming Messages]\n</code></pre>"},{"location":"messagebus/#message-consumption-process","title":"Message Consumption Process","text":"<pre><code>flowchart TD\n    A[Message Received] --&gt; B[Create Task for Message]\n    B --&gt; C[Extract Message Type]\n    C --&gt; D[Deserialize Message]\n    D --&gt; E[Create MessageBusAppContext]\n    E --&gt; F[Setup BusMessageController]\n    F --&gt; G[Invoke Handler Function]\n    G --&gt;|Success| H[Acknowledge Message]\n    G --&gt;|Failure| I[Handle Exception]\n    I --&gt;|Retry| J[Requeue Message]\n    I --&gt;|Discard| K[Reject Message]\n</code></pre>"},{"location":"messagebus/#handler-registration","title":"Handler Registration","text":"<p>Jararaca uses a declarative approach to register message handlers through decorators.</p> <pre><code>classDiagram\n    class MessageBusController {\n        -messagebus_factory: Callable\n        +get_messagebus_factory()\n        +register()\n        +get_messagebus()\n    }\n\n    class MessageHandler {\n        -message_type: Type[Message]\n        -timeout: Optional[int]\n        -exception_handler: Optional[Callable]\n        -requeue_on_exception: bool\n        -auto_ack: bool\n        +register()\n        +get_message_incoming()\n    }\n\n    class MessageHandlerData {\n        +message_type: Type[Message]\n        +spec: MessageHandler\n        +callable: Callable\n    }\n\n    MessageBusController --&gt; MessageHandler\n    MessageHandler --&gt; MessageHandlerData\n</code></pre>"},{"location":"messagebus/#example-handler-definition","title":"Example Handler Definition","text":"<pre><code>from jararaca import Message, MessageBusController, MessageHandler, MessageOf\n\n\n@MessageBusController()\nclass UserEventsController:\n    @MessageHandler(UserCreatedMessage, timeout=30, nack_on_exception=True)\n    async def handle_user_created(self, message: MessageOf[UserCreatedMessage]):\n        user_data = message.payload()\n        # Process the message\n        print(f\"User created: {user_data.username}\")\n</code></pre>"},{"location":"messagebus/#message-control-flow","title":"Message Control Flow","text":"<p>During message processing, handlers can control the message acknowledgment flow.</p> <pre><code>sequenceDiagram\n    participant H as Handler\n    participant C as BusMessageController\n    participant Q as Queue\n\n    H-&gt;&gt;C: ack()\n    C-&gt;&gt;Q: Acknowledge Message\n\n    H-&gt;&gt;C: nack()\n    C-&gt;&gt;Q: Negative Acknowledge\n\n    H-&gt;&gt;C: reject()\n    C-&gt;&gt;Q: Reject Message\n\n    H-&gt;&gt;C: retry()\n    C-&gt;&gt;Q: Requeue Message\n</code></pre>"},{"location":"messagebus/#message-control-utilities","title":"Message Control Utilities","text":"<pre><code>from jararaca import ack, nack, reject, retry\n\n\n@MessageBusController()\nclass TaskProcessor:\n    @MessageHandler(TaskMessage, auto_ack=False)\n    async def process_task(self, message: MessageOf[TaskMessage]):\n        try:\n            task_data = message.payload()\n            # Process the task\n            await self.process_task_data(task_data)\n            # Manually acknowledge successful processing\n            await ack()\n        except TemporaryError:\n            # Request message retry\n            await retry()\n        except PermanentError:\n            # Reject the message\n            await reject()\n</code></pre>"},{"location":"messagebus/#error-handling","title":"Error Handling","text":"<p>The message bus provides comprehensive error handling mechanisms:</p> <pre><code>flowchart TD\n    A[Message Processing] --&gt;|Success| B[Acknowledge]\n    A --&gt;|Failure| C[Exception Handling]\n    C --&gt;|Has Exception Handler| D[Custom Handler]\n    C --&gt;|No Exception Handler| E[Default Logging]\n    D --&gt;|Requeue Configured| F[Retry Message]\n    D --&gt;|Discard Configured| G[Reject Message]\n    E --&gt;|Requeue Configured| F\n    E --&gt;|Discard Configured| G\n</code></pre>"},{"location":"messagebus/#integration-with-other-jararaca-components","title":"Integration with Other Jararaca Components","text":"<p>The message bus system integrates with other Jararaca components for a unified experience:</p> <pre><code>flowchart LR\n    A[Message Bus] &lt;--&gt; B[Database Sessions]\n    A &lt;--&gt; C[WebSockets]\n    A &lt;--&gt; D[Scheduler]\n    A &lt;--&gt; E[HTTP API]\n\n    B &lt;-- use_session --&gt; F[Shared Context]\n    C &lt;-- use_ws_manager --&gt; F\n    A &lt;-- use_publisher --&gt; F\n</code></pre>"},{"location":"messagebus/#websocket-integration-example","title":"WebSocket Integration Example","text":"<pre><code>@MessageBusController()\nclass NotificationController:\n    @MessageHandler(UserActivityMessage)\n    async def handle_user_activity(self, message: MessageOf[UserActivityMessage]):\n        user_data = message.payload()\n\n        # Create a WebSocket message\n        notification = ActivityNotification(\n            user_id=user_data.user_id,\n            action=user_data.action,\n            timestamp=user_data.timestamp\n        )\n\n        # Send to user's room using WebSocket\n        await notification.send(f\"user-{user_data.user_id}\")\n</code></pre>"},{"location":"messagebus/#command-line-usage","title":"Command Line Usage","text":"<p>You can start a message bus worker using the Jararaca CLI:</p> <pre><code>jararaca worker APP_PATH [OPTIONS]\n</code></pre> <p>Options:</p> <ul> <li><code>--broker-url</code>: The URL for the message broker (required) [env: BROKER_URL]</li> <li><code>--backend-url</code>: The URL for the message broker backend (required) [env: BACKEND_URL]</li> <li><code>--handlers</code>: Comma-separated list of handler names to listen to (optional) [env: HANDLERS]</li> <li><code>--reload</code>: Enable auto-reload when Python files change (for development) [env: RELOAD]</li> <li><code>--src-dir</code>: The source directory to watch for changes when --reload is enabled (default: \"src\") [env: SRC_DIR]</li> </ul> <p>Examples:</p> <pre><code># Standard worker execution\njararaca worker myapp.main:app --broker-url \"amqp://guest:guest@localhost:5672/?exchange=jararaca\" --backend-url \"redis://localhost:6379\"\n\n# With auto-reload for development\njararaca worker myapp.main:app --broker-url \"amqp://guest:guest@localhost:5672/?exchange=jararaca\" --backend-url \"redis://localhost:6379\" --reload\n\n# Using environment variables\nexport APP_PATH=\"myapp.main:app\"\nexport BROKER_URL=\"amqp://guest:guest@localhost:5672/?exchange=jararaca\"\nexport BACKEND_URL=\"redis://localhost:6379\"\nexport RELOAD=\"true\"\nexport SRC_DIR=\"src\"\nexport RELOAD=\"true\"\njararaca worker\n</code></pre>"},{"location":"messagebus/#conclusion","title":"Conclusion","text":"<p>The Jararaca message bus system provides a powerful, type-safe way to implement asynchronous processing in your applications. With its integration with other Jararaca components, it enables building distributed systems with unified context and utilities across different runtime environments.</p>"},{"location":"retry/","title":"Retry Mechanism with Exponential Backoff","text":"<p>Jararaca implements a robust retry mechanism with exponential backoff for handling transient failures in RabbitMQ connections and operations. This mechanism helps the system gracefully handle temporary network issues, broker unavailability, and other transient failures.</p>"},{"location":"retry/#core-components","title":"Core Components","text":"<p>The retry system consists of these main components:</p> <ol> <li><code>RetryConfig</code> - Configuration class for customizing retry behavior</li> <li><code>retry_with_backoff</code> - Utility function to execute operations with retry</li> <li><code>with_retry</code> - Decorator for applying retry logic to functions</li> </ol>"},{"location":"retry/#retry-configuration","title":"Retry Configuration","text":"<p>The <code>RetryConfig</code> class allows customization of various retry parameters:</p> <pre><code>class RetryConfig:\n    def __init__(\n        self,\n        max_retries: int = 5,         # Maximum number of retry attempts\n        initial_delay: float = 1.0,    # Initial delay between retries (seconds)\n        max_delay: float = 60.0,       # Maximum delay between retries (seconds)\n        backoff_factor: float = 2.0,   # Multiplier for delay after each retry\n        jitter: bool = True,           # Add randomness to delay to prevent thundering herd\n    ):\n        ...\n</code></pre>"},{"location":"retry/#integration-with-messagebus-worker","title":"Integration with MessageBus Worker","text":"<p>The RabbitMQ consumer in the message bus system uses the retry mechanism in several key areas:</p> <ol> <li> <p>Connection Establishment: When establishing a connection to RabbitMQ, the system will automatically retry with increasing backoff periods if the connection fails.</p> </li> <li> <p>Channel Creation: When creating channels for publishing or consuming messages, failures trigger the retry mechanism.</p> </li> <li> <p>Consumer Setup: Setting up message consumers uses retry logic to handle temporary failures.</p> </li> </ol>"},{"location":"retry/#url-configuration-parameters","title":"URL Configuration Parameters","text":"<p>Retry behavior can be customized through URL parameters when configuring the RabbitMQ connection:</p> Parameter Description Default <code>connection_retry_max</code> Maximum number of connection retry attempts 5 <code>connection_retry_delay</code> Initial delay between connection retries (seconds) 1.0 <code>connection_retry_max_delay</code> Maximum delay between connection retries (seconds) 60.0 <code>connection_retry_backoff</code> Multiplier for delay after each connection retry 2.0 <code>consumer_retry_max</code> Maximum number of consumer setup retry attempts 3 <code>consumer_retry_delay</code> Initial delay between consumer setup retries (seconds) 0.5 <code>consumer_retry_max_delay</code> Maximum delay between consumer setup retries (seconds) 5.0 <code>consumer_retry_backoff</code> Multiplier for delay after each consumer setup retry 2.0"},{"location":"retry/#example-usage","title":"Example Usage","text":"<pre><code># Configure with custom retry settings in URL:\nbroker_url = \"amqp://guest:guest@localhost:5672/?exchange=jararaca&amp;prefetch_count=10&amp;connection_retry_max=10&amp;connection_retry_delay=2.0\"\n\n# Use custom retry configuration in code:\nfrom jararaca.utils.retry import RetryConfig, retry_with_backoff\n\nconfig = RetryConfig(max_retries=3, initial_delay=1.0, max_delay=30.0)\n\nasync def connect_with_retry():\n    return await retry_with_backoff(\n        establish_connection,\n        retry_config=config,\n        retry_exceptions=(ConnectionError, TimeoutError)\n    )\n</code></pre>"},{"location":"retry/#benefits","title":"Benefits","text":"<ol> <li>Resilience - The system can recover automatically from transient failures</li> <li>Reduced downtime - Automatic reconnection minimizes service disruption</li> <li>Configuration flexibility - Retry behavior can be tailored to different environments</li> <li>Smart backoff - Exponential backoff with jitter prevents overloading services during recovery</li> </ol>"},{"location":"scheduler/","title":"Jararaca Scheduler System","text":"<p>The scheduler system in Jararaca provides robust task scheduling capabilities that allow you to run periodic tasks using cron expressions. This document explains how the scheduler works, its different implementations, and how to use it in your applications.</p>"},{"location":"scheduler/#overview","title":"Overview","text":"<p>The Jararaca scheduler allows you to:</p> <ul> <li>Run background tasks at scheduled intervals</li> <li>Use cron expressions for flexible scheduling</li> <li>Control overlap behavior (whether to allow multiple instances of the same task)</li> <li>Distribute scheduled tasks across multiple instances</li> <li>Handle delayed message execution</li> </ul> <p>The scheduler is implemented through the BeatWorker which provides distributed task scheduling via a message broker:</p> <pre><code>graph TD\n    A[Microservice] --&gt; B[BeatWorker]\n    B --&gt; C[Message Broker]\n    B --&gt; D[Backend Store]\n    C --&gt; E[Message Processing]\n    D --&gt; F[Last Execution Time]\n    D --&gt; G[Delayed Messages]\n</code></pre>"},{"location":"scheduler/#using-the-scheduler","title":"Using the Scheduler","text":""},{"location":"scheduler/#defining-scheduled-tasks","title":"Defining Scheduled Tasks","text":"<p>You can define scheduled tasks using the <code>@ScheduledAction</code> decorator:</p> <pre><code>from jararaca import ScheduledAction\n\n\nclass TasksController:\n    @ScheduledAction(\"*/5 * * * *\")  # Run every 5 minutes\n    async def scheduled_task(self):\n        # Your task implementation\n        print(\"This runs every 5 minutes\")\n\n    @ScheduledAction(\"0 */2 * * *\", allow_overlap=False, timeout=60)\n    async def heavy_task(self):\n        # A heavier task that shouldn't overlap\n        print(\"This runs every 2 hours without overlap\")\n</code></pre>"},{"location":"scheduler/#scheduler-decorator-options","title":"Scheduler Decorator Options","text":"<p>The <code>@ScheduledAction</code> decorator accepts several parameters:</p> <ul> <li><code>cron</code>: A string representing the cron expression for the scheduled action</li> <li><code>allow_overlap</code>: A boolean indicating if new executions should start even if the previous one is still running (default: <code>False</code>)</li> <li><code>exclusive</code>: A boolean indicating if the scheduled action should be executed in only one instance of the application (requires a distributed backend, default: <code>True</code>)</li> <li><code>timeout</code>: An integer representing the timeout for the scheduled action in seconds (default: <code>None</code>)</li> <li><code>exception_handler</code>: A callable that will be called when an exception is raised during execution (default: <code>None</code>)</li> </ul>"},{"location":"scheduler/#cron-expressions","title":"Cron Expressions","text":"<p>Jararaca uses standard cron expressions for scheduling. Here are some examples:</p> <ul> <li><code>* * * * *</code> - Run every minute</li> <li><code>*/15 * * * *</code> - Run every 15 minutes</li> <li><code>0 * * * *</code> - Run at the beginning of every hour</li> <li><code>0 0 * * *</code> - Run at midnight every day</li> <li><code>0 0 * * 0</code> - Run at midnight every Sunday</li> <li><code>0 0 1 * *</code> - Run at midnight on the first day of every month</li> </ul>"},{"location":"scheduler/#using-the-beatworker-scheduler","title":"Using the BeatWorker Scheduler","text":"<p>The BeatWorker scheduler provides distributed task execution through a message broker:</p> <pre><code>from jararaca import Microservice, ScheduledAction\nfrom jararaca.scheduler.beat_worker import BeatWorker\n\napp = Microservice(\n    # Your microservice configuration\n)\n\n# Run the scheduler\nbeat_worker = BeatWorker(\n    app=app,\n    interval=1,\n    backend_url=\"redis://localhost:6379\",\n    broker_url=\"amqp://guest:guest@localhost:5672/?exchange=jararaca\",\n    scheduled_action_names=None  # Optional set of action names to run\n)\nbeat_worker.run()\n</code></pre> <p>You can also use the CLI command to run the scheduler:</p> <pre><code># Standard beat scheduler execution\njararaca beat app_module:app --interval 1 --broker-url \"amqp://guest:guest@localhost:5672/?exchange=jararaca\" --backend-url \"redis://localhost:6379\"\n\n# With auto-reload for development (automatically restarts when Python files change)\njararaca beat app_module:app --interval 1 --broker-url \"amqp://guest:guest@localhost:5672/?exchange=jararaca\" --backend-url \"redis://localhost:6379\" --reload\n\n# Using environment variables\nexport APP_PATH=\"app_module:app\"\nexport INTERVAL=\"1\"\nexport BROKER_URL=\"amqp://guest:guest@localhost:5672/?exchange=jararaca\"\nexport BACKEND_URL=\"redis://localhost:6379\"\nexport RELOAD=\"true\"\nexport SRC_DIR=\"src\"\njararaca beat\n</code></pre> <p>All command options support environment variables: - <code>APP_PATH</code>: The application module path [required] - <code>INTERVAL</code>: Polling interval in seconds [default: 1] - <code>BROKER_URL</code>: The URL for the message broker [required] - <code>BACKEND_URL</code>: The URL for the message broker backend [required] - <code>ACTIONS</code>: Comma-separated list of action names to run [optional] - <code>RELOAD</code>: Enable auto-reload when Python files change [optional] - <code>SRC_DIR</code>: The source directory to watch for changes when using reload [default: \"src\"] <pre><code>app = Microservice(\n    # Your microservice configuration\n)\n\n# Run the enhanced scheduler\nscheduler = SchedulerV2(\n    app=app,\n    interval=1,\n    broker_url=\"amqp://guest:guest@localhost:5672/?exchange=jararaca_ex\",\n    backend_url=\"redis://localhost:6379\",\n)\nscheduler.run()\n</code></pre></p>"},{"location":"scheduler/#message-broker-integration","title":"Message Broker Integration","text":"<p>The V2 scheduler uses a message broker (currently supporting RabbitMQ) to distribute tasks:</p> <ol> <li>The scheduler determines when a task should run based on its cron expression</li> <li>Instead of executing the task directly, it sends a message to the message broker</li> <li>A worker picks up the message and executes the task</li> <li>The backend store (Redis) tracks execution state to prevent overlap when configured</li> </ol> <p>This architecture allows for better scalability and reliability:</p> <pre><code>sequenceDiagram\n    participant S as SchedulerV2\n    participant B as Message Broker\n    participant R as Redis Backend\n    participant W as Worker\n\n    S-&gt;&gt;R: Check last execution time\n    R--&gt;&gt;S: Return last execution time\n    S-&gt;&gt;S: Determine if task should run\n    S-&gt;&gt;B: Publish task message\n    S-&gt;&gt;R: Update last execution time\n    B--&gt;&gt;W: Deliver task message\n    W-&gt;&gt;R: Mark task as running\n    W-&gt;&gt;W: Execute task\n    W-&gt;&gt;R: Mark task as completed\n</code></pre>"},{"location":"scheduler/#delayed-message-queue","title":"Delayed Message Queue","text":"<p>The V2 scheduler also supports delayed messages:</p> <pre><code>from jararaca import use_publisher\nfrom jararaca.scheduler.types import DelayedMessageData\n\n\n# Schedule a message to be published at a future time\nasync def schedule_reminder():\n    message = ReminderMessage(\n        user_id=\"123\",\n        message=\"Don't forget your appointment!\"\n    )\n\n    # Current time + 1 hour in seconds\n    dispatch_time = int(time.time()) + 3600\n\n    # Get publisher\n    publisher = use_publisher()\n\n    # Schedule delayed message\n    await publisher.publish_delayed(\n        message,\n        dispatch_time=dispatch_time\n    )\n</code></pre>"},{"location":"scheduler/#redis-backend-implementation","title":"Redis Backend Implementation","text":"<p>The Redis backend implementation provides:</p> <ol> <li>Distributed Locking - Ensures tasks only run on one instance when exclusivity is required</li> <li>Execution Tracking - Tracks the running state of tasks to prevent overlap</li> <li>Delayed Message Queue - Manages messages scheduled for future delivery</li> </ol> <p>The implementation uses Redis data structures: - Keys for last execution time and dispatch time - Sorted sets for delayed message queue - Hash sets for execution indicators</p>"},{"location":"scheduler/#running-the-scheduler","title":"Running the Scheduler","text":""},{"location":"scheduler/#cli-command-for-basic-scheduler","title":"CLI Command for Basic Scheduler","text":"<pre><code>jararaca scheduler APP_PATH [OPTIONS]\n</code></pre> <p>Options: - <code>--interval</code>: Polling interval in seconds (default: 1)</p>"},{"location":"scheduler/#cli-command-for-enhanced-scheduler-v2","title":"CLI Command for Enhanced Scheduler (V2)","text":"<pre><code>jararaca scheduler_v2 APP_PATH [OPTIONS]\n</code></pre> <p>Options: - <code>--interval</code>: Polling interval in seconds (default: 1, required) - <code>--broker-url</code>: The URL for the message broker (required) - <code>--backend-url</code>: The URL for the message broker backend (required)</p>"},{"location":"scheduler/#best-practices","title":"Best Practices","text":"<ol> <li>Task Duration - Be mindful of task duration, especially for frequent tasks</li> <li>Error Handling - Implement proper error handling in your tasks</li> <li>Overlap Control - Use <code>allow_overlap=False</code> for resource-intensive tasks</li> <li>Timeouts - Set appropriate timeouts to prevent stuck tasks</li> <li>Monitoring - Log task execution for monitoring purposes</li> </ol>"},{"location":"scheduler/#conclusion","title":"Conclusion","text":"<p>The Jararaca scheduler system provides a powerful, flexible way to implement periodic tasks in your applications. With two implementations to choose from, you can select the one that best fits your application's requirements, from simple local scheduling to complex distributed task execution.</p>"},{"location":"websocket/","title":"Distributed WebSocket in Jararaca","text":"<p>Jararaca provides a powerful distributed WebSocket system that enables real-time communication across multiple server instances. This document explains how the WebSocket system works, its architecture, and how to use it in your applications.</p>"},{"location":"websocket/#overview","title":"Overview","text":"<p>The WebSocket system in Jararaca is designed for scalability and ease of use, with the following key features:</p> <ul> <li>One-way communication pattern: WebSockets are used for server-to-client messages only, with client-to-server communication happening via REST API</li> <li>Room-based communication: WebSocket connections can be grouped into logical rooms for targeted messaging</li> <li>Cross-instance messaging: Messages can be broadcast across multiple server instances</li> <li>Redis-backed distribution: Uses Redis pub/sub for reliable message distribution</li> <li>Seamless integration: Works with FastAPI's WebSocket support</li> <li>Type-safe messaging: Leverages Pydantic for structured WebSocket messages</li> </ul> <pre><code>graph TD\n    A[WebSocket Client] &lt;-- Server to Client --&gt; B[Jararaca Instance 1]\n    A &lt;-- Server to Client --&gt; C[Jararaca Instance 2]\n    A &lt;-- Server to Client --&gt; D[Jararaca Instance 3]\n\n    A -- Client to Server via REST --&gt; B\n    A -- Client to Server via REST --&gt; C\n    A -- Client to Server via REST --&gt; D\n\n    B &lt;--&gt; E[Redis PubSub]\n    C &lt;--&gt; E\n    D &lt;--&gt; E\n\n    subgraph \"Distributed Communication\"\n        E\n    end\n</code></pre>"},{"location":"websocket/#architecture-components","title":"Architecture Components","text":"<p>The WebSocket system consists of several key components that work together:</p>"},{"location":"websocket/#1-websocketmessagebase","title":"1. WebSocketMessageBase","text":"<p>The base class for all WebSocket messages. Messages are structured, validated, and serialized using Pydantic.</p> <pre><code>class WebSocketMessageBase(BaseModel):\n    MESSAGE_ID: ClassVar[str] = \"__UNSET__\"\n</code></pre>"},{"location":"websocket/#2-websocketmessage","title":"2. WebSocketMessage","text":"<p>A concrete message class that adds functionality for sending messages to specific rooms.</p> <pre><code>class WebSocketMessage(WebSocketMessageBase):\n    async def send(self, *rooms: str) -&gt; None:\n        await use_ws_manager().send(list(rooms), self)\n</code></pre>"},{"location":"websocket/#3-websocketconnectionmanager","title":"3. WebSocketConnectionManager","text":"<p>A Protocol that defines the interface for managing WebSocket connections:</p> <pre><code>class WebSocketConnectionManager(Protocol):\n    async def broadcast(self, message: bytes) -&gt; None: ...\n    async def send(self, rooms: list[str], message: WebSocketMessageBase) -&gt; None: ...\n    async def join(self, rooms: list[str], websocket: WebSocket) -&gt; None: ...\n    async def add_websocket(self, websocket: WebSocket) -&gt; None: ...\n    async def remove_websocket(self, websocket: WebSocket) -&gt; None: ...\n</code></pre> <p>The WebSocketConnectionManager: - Maintains a registry of active WebSocket connections - Groups connections into named rooms - Provides methods for broadcasting and sending targeted messages</p>"},{"location":"websocket/#4-context-based-websocket-access","title":"4. Context-based WebSocket Access","text":"<p>Jararaca uses context variables to provide access to WebSocket functionality anywhere in your application:</p> <pre><code>from jararaca.presentation.websocket.context import use_ws_manager, use_ws_message_sender\n\n# Send a message to specific rooms\nasync def notify_users(message_data: dict, room_id: str):\n    message = UserNotificationMessage(**message_data)\n    await use_ws_message_sender().send([room_id], message)\n\n# Or directly from a WebSocketMessage instance\nasync def send_update(update_data: dict, room_id: str):\n    message = SystemUpdateMessage(**update_data)\n    await message.send(room_id)\n</code></pre>"},{"location":"websocket/#5-rediswebsocketconnectionbackend","title":"5. RedisWebSocketConnectionBackend","text":"<p>The Redis-based implementation of the WebSocketConnectionBackend:</p> <ul> <li>Uses Redis pub/sub channels for message distribution</li> <li>Enables cross-instance communication</li> <li>Handles message serialization and deserialization</li> </ul>"},{"location":"websocket/#6-websocketinterceptor","title":"6. WebSocketInterceptor","text":"<p>The interceptor that integrates everything with the Jararaca framework:</p> <ul> <li>Manages WebSocket lifecycle</li> <li>Provides a connection manager for WebSocket endpoints</li> <li>Registers WebSocket routes with FastAPI</li> </ul>"},{"location":"websocket/#message-flow","title":"Message Flow","text":"<p>When sending WebSocket messages in a distributed environment, the flow is as follows:</p> <pre><code>sequenceDiagram\n    participant C as Client\n    participant I1 as Instance 1\n    participant R as Redis\n    participant I2 as Instance 2\n\n    C-&gt;&gt;I1: Connect to WebSocket\n    I1-&gt;&gt;I1: Register connection\n    C-&gt;&gt;I1: Join room \"room1\"\n    I1-&gt;&gt;I1: Add to room \"room1\"\n\n    C-&gt;&gt;I1: Send message\n    I1-&gt;&gt;R: Publish to channel\n    R-&gt;&gt;I2: Deliver to subscribers\n    I2-&gt;&gt;C: Forward to clients in room\n</code></pre> <ol> <li>Message Creation: A <code>WebSocketMessage</code> is created and sent to specific rooms</li> <li>Local Delivery: The message is delivered to connections in those rooms on the current instance</li> <li>Redis Publication: The message is published to Redis channels</li> <li>Cross-Instance Distribution: Other instances receive the message from Redis</li> <li>Remote Delivery: Other instances deliver the message to their connected clients in the target rooms</li> </ol>"},{"location":"websocket/#using-the-websocket-system","title":"Using the WebSocket System","text":""},{"location":"websocket/#defining-websocket-messages","title":"Defining WebSocket Messages","text":"<p>Create custom message types by extending the <code>WebSocketMessage</code> class:</p> <pre><code>from jararaca import WebSocketMessage\n\nclass ChatMessage(WebSocketMessage):\n    MESSAGE_ID = \"chat.message\"\n\n    user_id: str\n    username: str\n    content: str\n    timestamp: str\n</code></pre>"},{"location":"websocket/#setting-up-the-websocket-interceptor","title":"Setting Up the WebSocket Interceptor","text":"<p>Configure the WebSocket interceptor in your Jararaca application:</p> <pre><code>from jararaca import (\n    Microservice,\n    WebSocketInterceptor,\n    RedisWebSocketConnectionBackend,\n)\nfrom redis.asyncio import Redis\n\napp = Microservice(\n    # ...other configuration...\n    interceptors=[\n        # ...other interceptors...\n        WebSocketInterceptor(\n            backend=RedisWebSocketConnectionBackend(\n                send_pubsub_channel=\"jararaca:websocket:send\",\n                broadcast_pubsub_channel=\"jararaca:websocket:broadcast\",\n                conn=Redis.from_url(\"redis://localhost\", decode_responses=False),\n            )\n        ),\n    ],\n)\n</code></pre>"},{"location":"websocket/#creating-websocket-endpoints","title":"Creating WebSocket Endpoints","text":"<p>Define WebSocket endpoints using the <code>@WebSocketEndpoint</code> decorator:</p> <pre><code>from jararaca import WebSocketEndpoint, RestController, use_ws_manager\nfrom fastapi import WebSocket, APIRouter\nfrom pydantic import BaseModel\n\n# Model for client-to-server REST communication\nclass ChatMessageRequest(BaseModel):\n    content: str\n\n@RestController(\"/chat\")\nclass ChatController:\n    def __init__(self):\n        self.router = APIRouter()\n\n    # REST endpoint for client-to-server communication\n    @self.router.post(\"/{room_id}/message\")\n    async def send_message(self, room_id: str, message: ChatMessageRequest):\n        # Process the message from client\n        # ...\n\n        # Create and send response via WebSocket to all clients in the room\n        ws_message = ChatMessage(\n            user_id=\"123\",\n            username=\"user1\",\n            content=message.content,\n            timestamp=\"2025-04-17T12:34:56Z\"\n        )\n\n        await ws_message.send(room_id)\n        return {\"status\": \"sent\"}\n\n    # WebSocket endpoint for server-to-client communication only\n    @WebSocketEndpoint(\"/ws/{room_id}\")\n    async def chat_endpoint(self, websocket: WebSocket, room_id: str):\n        await websocket.accept()\n\n        # Get the WebSocket manager\n        ws_manager = use_ws_manager()\n\n        # Add socket to room\n        await ws_manager.add_websocket(websocket)\n        await ws_manager.join([room_id], websocket)\n\n        try:\n            # Keep the connection alive\n            # Note: We don't process messages from the client via WebSocket\n            # Clients should use the REST endpoints for sending messages\n            while True:\n                # This only keeps the connection alive\n                # Any data received is ignored as client should use REST API\n                await websocket.receive()\n\n        except:\n            # Handle disconnection\n            await ws_manager.remove_websocket(websocket)\n</code></pre>"},{"location":"websocket/#client-implementation-example","title":"Client Implementation Example","text":"<p>Here's how a client might interact with the system:</p> <pre><code>// Client-side JavaScript\n\n// For sending messages TO the server (via REST API)\nasync function sendMessage(roomId, content) {\n  const response = await fetch(`/chat/${roomId}/message`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({ content })\n  });\n  return response.json();\n}\n\n// For receiving messages FROM the server (via WebSocket)\nconst socket = new WebSocket(`ws://your-server.com/ws/${roomId}`);\n\nsocket.onmessage = (event) =&gt; {\n  const message = JSON.parse(event.data);\n  // Handle incoming message from server\n  displayMessage(message);\n};\n\n// Usage example\ndocument.getElementById('send-button').addEventListener('click', () =&gt; {\n  const content = document.getElementById('message-input').value;\n  sendMessage(roomId, content);\n});\n</code></pre>"},{"location":"websocket/#broadcasting-messages","title":"Broadcasting Messages","text":"<p>To broadcast a message to all connected clients:</p> <pre><code># Create the message\nnotification = SystemNotification(\n    message=\"System maintenance in 5 minutes\",\n    severity=\"warning\",\n    timestamp=\"2025-04-17T12:30:00Z\"\n)\n\n# Broadcast as bytes\nws_manager = use_ws_manager()\nawait ws_manager.broadcast(\n    notification.model_dump_json().encode()\n)\n</code></pre>"},{"location":"websocket/#sending-to-specific-rooms","title":"Sending to Specific Rooms","text":"<p>To send a message to specific rooms:</p> <pre><code># Send directly with the message\nawait chat_message.send(\"room1\", \"room2\")\n\n# Or use the manager\nawait ws_manager.send([\"room1\", \"room2\"], chat_message)\n</code></pre>"},{"location":"websocket/#integration-with-message-bus","title":"Integration with Message Bus","text":"<p>One of Jararaca's powerful features is the ability to seamlessly integrate the WebSocket system with the message bus:</p> <pre><code>@MessageBusController()\nclass NotificationController:\n    @MessageHandler(UserActivityMessage)\n    async def handle_user_activity(self, message: MessageOf[UserActivityMessage]):\n        user_data = message.payload()\n\n        # Create a WebSocket message\n        notification = ActivityNotification(\n            user_id=user_data.user_id,\n            action=user_data.action,\n            timestamp=user_data.timestamp\n        )\n\n        # Send to user's room\n        await notification.send(f\"user-{user_data.user_id}\")\n</code></pre> <p>This allows background processes to send real-time updates to connected clients, enabling truly reactive applications.</p>"},{"location":"websocket/#under-the-hood-redis-implementation","title":"Under the Hood: Redis Implementation","text":"<p>The <code>RedisWebSocketConnectionBackend</code> uses Redis pub/sub channels to distribute messages across multiple Jararaca instances:</p> <ol> <li>Message Publishing:</li> <li>When sending to rooms, messages are published to the <code>send_pubsub_channel</code></li> <li>When broadcasting, messages are published to the <code>broadcast_pubsub_channel</code></li> <li> <p>Messages are serialized into a specific format for transmission</p> </li> <li> <p>Message Consumption:</p> </li> <li>Each instance subscribes to both channels</li> <li>When messages arrive, they're decoded and forwarded to the appropriate WebSocket connections</li> <li> <p>Background tasks handle message consumption and delivery</p> </li> <li> <p>Room Management:</p> </li> <li>Each instance maintains its own registry of rooms and connections</li> <li>Messages for specific rooms are only delivered to instances with connections in those rooms</li> </ol>"},{"location":"websocket/#best-practices","title":"Best Practices","text":"<ol> <li>Message Structure: Keep WebSocket messages focused and well-structured</li> <li>Room Naming: Use consistent naming conventions for rooms (e.g., <code>user-{user_id}</code>, <code>chat-{chat_id}</code>)</li> <li>Error Handling: Always handle WebSocket disconnections properly</li> <li>Message Validation: Leverage Pydantic's validation to ensure message integrity</li> <li>Scaling: Monitor Redis performance when scaling to many instances or high message volumes</li> </ol>"},{"location":"websocket/#conclusion","title":"Conclusion","text":"<p>Jararaca's distributed WebSocket system provides a powerful way to add real-time communication capabilities to your applications. By combining WebSockets with the message bus system, you can build truly reactive applications where events from any part of your system can trigger real-time updates to connected clients.</p>"}]}